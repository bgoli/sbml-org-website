<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libSBML C# API: Mathematical Expressions and their Manipulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C# API
   &#160;<span id="projectnumber">5.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="group__core.html"><span>Core&#160;libSBML</span></a></li>
      <li><a href="usergroup0.html"><span>Level&#160;3&#160;Extensions</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="libsbml-csharp-example-files.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('libsbml-csharp-math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Mathematical Expressions and their Manipulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes libSBML's facilities for working with SBML representations of mathematical expressions.</p>
<h1><a class="anchor" id="math-overview"></a>
Basic concepts</h1>
<p>LibSBML uses <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Trees</a> (ASTs) to provide a canonical, in-memory representation for all mathematical formulas regardless of their original format (i.e., C-like infix strings or <a href="http://www.w3.org/Math/">MathML</a>). In libSBML, an AST is a collection of one or more objects of type <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a>. An AST <em>node</em> in libSBML is a recursive structure containing a pointer to the node's value (which might be, for example, a number or a symbol) and a list of children nodes. Each <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> node may have none, one, two, or more child depending on its type. The following diagram illustrates an example of how the mathematical expression <code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node having two <em>integer</em> children nodes for the numbers <code>1</code> and <code>2</code>. The figure also shows the corresponding <a href="http://www.w3.org/Math/">MathML&#160;2.0</a> representation:</p>
<table border="0" class="centered text-table width80 normal-font" style="padding-bottom: 0.5em">
<caption class="top-caption">Example AST representation of a mathematical expression.</caption>
<tr>
<th width="50px">Infix</th>
<th>AST</th>
<th>MathML</th>
</tr>
<tr>
<td valign="middle" align="center">
<code>1 + 2</code>
</td>
<td valign="middle">
  <object type="image/svg+xml" data="simple-ast.svg" class="centered" width="140px"></object>
</td>
<td valign="middle">
<code>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;</code><br>
<code>&nbsp;&nbsp;&lt;apply&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;plus/&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 1 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 2 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&lt;/apply&gt;</code><br>
<code>&lt;/math&gt;</code>
</td>
</tr>
</table>
<p>The following are noteworthy about the AST representation in libSBML:</p>
<ul>
<li>A numerical value represented in <a href="http://www.w3.org/Math/">MathML&#160;2.0</a> as a real number with an exponent is preserved as such in the AST node representation, even if the number could be stored in a <code>double</code> data type. This is done so that when an SBML model is read in and then written out again, the amount of change introduced by libSBML to the SBML during the round-trip activity is minimized. </li>
<li>Rational numbers are represented in an AST node using separate numerator and denominator values. These can be retrieved using the methods <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a03a753ef626952d3b04c8535fbe31e8e" title="Gets the value of the numerator of this node. ">libsbmlcs.ASTNode.getNumerator()</a> and <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a59db65cf90bb59694ef71d658945bed9" title="Gets the value of the denominator of this node. ">libsbmlcs.ASTNode.getDenominator()</a>. </li>
<li>The children of an <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> are other <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> objects. The list of children is empty for nodes that are leaf elements, such as numbers. For nodes that are actually roots of expression subtrees, the list of children points to the parsed objects that make up the rest of the expression.</li>
</ul>
<p>For many applications, the details of ASTs are irrelevant because the applications can use the text-string based translation functions such as libsbmlcs.formulaToString(), libsbmlcs.parseL3Formula(), and libsbmlcs.parseFormula(). If you find the complexity of using the AST representation of expressions too high for your purposes, perhaps the string-based functions will be more suitable.</p>
<p>Finally, it is worth noting that the AST and MathML handling code in libSBML remains written in C, not C++, as all of libSBML was originally written in C. Readers may occasionally wonder why some aspects are more C-like than following a C++ style, and that's the reason.</p>
<h1><a class="anchor" id="math-convert"></a>
Converting between ASTs and Text Strings</h1>
<p>SBML Levels 2 and 3 represents mathematical expressions using <a href="http://www.w3.org/Math/">MathML&#160;2.0</a> (more specifically, a subset of the <em>content</em> portion of MathML&#160;2.0), but most software applications using libSBML do not use MathML directly. Instead, applications generally either interact with mathematics in text-string form, or else they use the API for working with Abstract Syntax Trees (described below). LibSBML provides support for both approaches. The libSBML formula parser has been carefully engineered so that transformations from MathML to infix string notation <em>and back</em> is possible with a minimum of disruption to the structure of the mathematical expression.</p>
<p>The example below shows a simple program that, when run, takes a MathML string compiled into the program, converts it to an AST, converts <em>that</em> to an infix representation of the formula, compares it to the expected form of that formula, and finally translates that formula back to MathML and displays it. The output displayed on the terminal should have the same structure as the MathML it started with. The program is a simple example of using the various MathML and AST reading and writing methods, and shows that libSBML preserves the ordering and structure of the mathematical expressions.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespace_system.html">System</a>;</div><div class="line"><span class="keyword">using</span> libsbml;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Example</div><div class="line">{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> Main(String[] args)</div><div class="line">    {</div><div class="line">        String expected = <span class="stringliteral">&quot;1 + f(x)&quot;</span>;</div><div class="line">        String input_mathml = <span class="stringliteral">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;</span></div><div class="line">          + <span class="stringliteral">&quot;&lt;math xmlns=&#39;http://www.w3.org/1998/Math/MathML&#39;&gt;&quot;</span></div><div class="line">          + <span class="stringliteral">&quot;  &lt;apply&gt; &lt;plus/&gt; &lt;cn&gt; 1 &lt;/cn&gt;&quot;</span></div><div class="line">          + <span class="stringliteral">&quot;                  &lt;apply&gt; &lt;ci&gt; f &lt;/ci&gt; &lt;ci&gt; x &lt;/ci&gt; &lt;/apply&gt;&quot;</span></div><div class="line">          + <span class="stringliteral">&quot;  &lt;/apply&gt;&quot;</span></div><div class="line">          + <span class="stringliteral">&quot;&lt;/math&gt;&quot;</span>;</div><div class="line"></div><div class="line">        ASTNode ast_result   = <a class="code" href="namespacelibsbmlcs.html">libsbmlcs</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html">libsbml</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html#aef52474edb68579004c2c76d9f89e7bd">readMathMLFromString</a>(input_mathml);</div><div class="line">        String ast_as_string = <a class="code" href="namespacelibsbmlcs.html">libsbmlcs</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html">libsbml</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html#a74553b46755f6654fd75f00b736f0bec">formulaToString</a>(ast_result);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (ast_as_string == expected)</div><div class="line">        {</div><div class="line">            Console.WriteLine(<span class="stringliteral">&quot;Got expected result.&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            Console.WriteLine(<span class="stringliteral">&quot;Mismatch after readMathMLFromString().&quot;</span>);</div><div class="line">            Environment.Exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        ASTNode new_mathml = <a class="code" href="namespacelibsbmlcs.html">libsbmlcs</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html">libsbml</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html#ae5778d595fdf4716aaca7db3aad48922">parseFormula</a>(ast_as_string);</div><div class="line">        String new_string = <a class="code" href="namespacelibsbmlcs.html">libsbmlcs</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html">libsbml</a>.<a class="code" href="classlibsbmlcs_1_1libsbml.html#aa35a7684b9eea4e556a93b8c449ffd1f">writeMathMLToString</a>(new_mathml);</div><div class="line"></div><div class="line">        Console.WriteLine(<span class="stringliteral">&quot;Result of writing AST to string:&quot;</span>);</div><div class="line">        Console.WriteLine(new_string);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The text-string form of mathematical formulas produced by <a class="el" href="classlibsbmlcs_1_1libsbml.html#a74553b46755f6654fd75f00b736f0bec" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">libsbmlcs.libsbml.formulaToString()</a> and read by <a class="el" href="classlibsbmlcs_1_1libsbml.html#a89e0d0f6a34ece57ddc7f37a8499e996" title="Parses a text string as a mathematical formula and returns an AST representation of it...">libsbmlcs.libsbml.parseL3Formula()</a> and <a class="el" href="classlibsbmlcs_1_1libsbml.html#ae5778d595fdf4716aaca7db3aad48922" title="Parses the given SBML formula and returns a representation of it as an Abstract Syntax Tree (AST)...">libsbmlcs.libsbml.parseFormula()</a> are in a simple C-inspired infix notation. It is summarized in the next section below. A formula in this text-string form therefore can be handed to a program that understands SBML mathematical expressions, or used as part of a translation system. In summary, the functions available are the following:</p>
<ul>
<li><a class="el" href="classlibsbmlcs_1_1libsbml.html#a74553b46755f6654fd75f00b736f0bec" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">libsbmlcs.libsbml.formulaToString(ASTNode)</a> <img class="formulaInl" alt="$\rightarrow$" src="form_0.png"/> <code>string</code> reads an AST, converts it to a text string in SBML Level&#160;1 formula syntax, and returns it. The caller owns the character string returned and should free it after it is no longer needed. </li>
<li><a class="el" href="classlibsbmlcs_1_1libsbml.html#ae5778d595fdf4716aaca7db3aad48922" title="Parses the given SBML formula and returns a representation of it as an Abstract Syntax Tree (AST)...">libsbmlcs.libsbml.parseFormula(string)</a> <img class="formulaInl" alt="$\rightarrow$" src="form_0.png"/> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> reads a text-string containing a mathematical expression in SBML Level&#160;1 syntax, and returns an AST corresponding to the expression. </li>
<li><a class="el" href="classlibsbmlcs_1_1libsbml.html#a89e0d0f6a34ece57ddc7f37a8499e996" title="Parses a text string as a mathematical formula and returns an AST representation of it...">libsbmlcs.libsbml.parseL3Formula(string)</a> <img class="formulaInl" alt="$\rightarrow$" src="form_0.png"/> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> reads a text-string containing a mathematical expression in an expanded syntax more compatible with SBML Levels&#160;2 and&#160;3, and returns an AST corresponding to the expression.</li>
</ul>
<h1><a class="anchor" id="math-diffs"></a>
The String Formula Syntax and Differences with MathML</h1>
<p>The text-string formula syntax is an infix notation essentially derived from the syntax of the C programming language and was originally used in SBML Level&#160;1. The formula strings may contain operators, function calls, symbols, and white space characters. The allowable white space characters are tab and space. The following are illustrative examples of formulas expressed in the syntax:</p>
<div class="fragment"><div class="line">0.10 * k4^2</div></div><!-- fragment --> <div class="fragment"><div class="line">(vm * s1)/(km + s1)</div></div><!-- fragment --><p>The following table shows the precedence rules in this syntax. In the Class column, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the Precedence column show how the order of different types of operation are determined. For example, the expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em> because the <code>*</code> operator has higher precedence. The Associates column shows how the order of similar precedence operations is determined; for example, <em>a - b + c</em> is evaluated as <em>(a - b) + c</em> because the <code>+</code> and <code>-</code> operators are left-associative. The precedence and associativity rules are taken from the C programming language, except for the symbol <code>^</code>, which is used in C for a different purpose. (Exponentiation can be invoked using either <code>^</code> or the function <code>power</code>.)</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>A program parsing a formula in an SBML model should assume that names appearing in the formula are the identifiers of <a class="el" href="classlibsbmlcs_1_1_species.html">Species</a>, <a class="el" href="classlibsbmlcs_1_1_parameter.html">Parameter</a>, <a class="el" href="classlibsbmlcs_1_1_compartment.html">Compartment</a>, <a class="el" href="classlibsbmlcs_1_1_function_definition.html">FunctionDefinition</a>, or <a class="el" href="classlibsbmlcs_1_1_reaction.html">Reaction</a> objects defined in a model. When a function call is involved, the syntax consists of a function identifier, followed by optional white space, followed by an opening parenthesis, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis. There is an almost one-to-one mapping between the list of predefined functions available, and those defined in MathML. All of the MathML funcctions are recognized; this set is larger than the functions defined in SBML Level 1. In the subset of functions that overlap between MathML and SBML Level 1, there exist a few differences. The following table summarizes the differences between the predefined functions in SBML Level 1 and the MathML equivalents in SBML Level 2:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Text string formula functions</th>
     <th align="left">MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(x)</code> or <code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(x)</code> or <code>root(2, x)</code></td></tr>
<caption class="top-caption">Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>

<h1><a class="anchor" id="math-ast"></a>
Methods for working with libSBML's Abstract Syntax Trees</h1>
<p>Every <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> in a libSBML AST has an associated type, a value taken from a set of constants with names beginning with <code>AST_</code> and defined in the interface class <a class="el" href="classlibsbmlcs_1_1libsbml.html">libsbml</a>. The list of possible types is quite long, because it covers all the mathematical functions that are permitted in SBML's subset of MathML. The values are shown in the following table; their names hopefully evoke the construct that they represent:</p>
<center> <table  width="80%" cellspacing="1" cellspacing="1" border="0">
<tr>
<td><code></code></td><td><code></code></td><td><code></code> </td></tr>
<tr>
<td><code>AST_UNKNOWN</code></td><td><code>AST_FUNCTION_ARCCOTH</code></td><td><code>AST_FUNCTION_POWER</code> </td></tr>
<tr>
<td><code>AST_PLUS</code></td><td><code>AST_FUNCTION_ARCCSC</code></td><td><code>AST_FUNCTION_ROOT</code> </td></tr>
<tr>
<td><code>AST_MINUS</code></td><td><code>AST_FUNCTION_ARCCSCH</code></td><td><code>AST_FUNCTION_SEC</code> </td></tr>
<tr>
<td><code>AST_TIMES</code></td><td><code>AST_FUNCTION_ARCSEC</code></td><td><code>AST_FUNCTION_SECH</code> </td></tr>
<tr>
<td><code>AST_DIVIDE</code></td><td><code>AST_FUNCTION_ARCSECH</code></td><td><code>AST_FUNCTION_SIN</code> </td></tr>
<tr>
<td><code>AST_POWER</code></td><td><code>AST_FUNCTION_ARCSIN</code></td><td><code>AST_FUNCTION_SINH</code> </td></tr>
<tr>
<td><code>AST_INTEGER</code></td><td><code>AST_FUNCTION_ARCSINH</code></td><td><code>AST_FUNCTION_TAN</code> </td></tr>
<tr>
<td><code>AST_REAL</code></td><td><code>AST_FUNCTION_ARCTAN</code></td><td><code>AST_FUNCTION_TANH</code> </td></tr>
<tr>
<td><code>AST_REAL_E</code></td><td><code>AST_FUNCTION_ARCTANH</code></td><td><code>AST_LOGICAL_AND</code> </td></tr>
<tr>
<td><code>AST_RATIONAL</code></td><td><code>AST_FUNCTION_CEILING</code></td><td><code>AST_LOGICAL_NOT</code> </td></tr>
<tr>
<td><code>AST_NAME</code></td><td><code>AST_FUNCTION_COS</code></td><td><code>AST_LOGICAL_OR</code> </td></tr>
<tr>
<td><code>AST_NAME_TIME</code></td><td><code>AST_FUNCTION_COSH</code></td><td><code>AST_LOGICAL_XOR</code> </td></tr>
<tr>
<td><code>AST_CONSTANT_E</code></td><td><code>AST_FUNCTION_COT</code></td><td><code>AST_RELATIONAL_EQ</code> </td></tr>
<tr>
<td><code>AST_CONSTANT_FALSE</code></td><td><code>AST_FUNCTION_COTH</code></td><td><code>AST_RELATIONAL_GEQ</code> </td></tr>
<tr>
<td><code>AST_CONSTANT_PI</code></td><td><code>AST_FUNCTION_CSC</code></td><td><code>AST_RELATIONAL_GT</code> </td></tr>
<tr>
<td><code>AST_CONSTANT_TRUE</code></td><td><code>AST_FUNCTION_CSCH</code></td><td><code>AST_RELATIONAL_LEQ</code> </td></tr>
<tr>
<td><code>AST_LAMBDA</code></td><td><code>AST_FUNCTION_EXP</code></td><td><code>AST_RELATIONAL_LT</code> </td></tr>
<tr>
<td><code>AST_FUNCTION</code></td><td><code>AST_FUNCTION_FACTORIAL</code></td><td><code>AST_RELATIONAL_NEQ</code> </td></tr>
<tr>
<td><code>AST_FUNCTION_ABS</code></td><td><code>AST_FUNCTION_FLOOR</code></td><td><code></code> </td></tr>
<tr>
<td><code>AST_FUNCTION_ARCCOS</code></td><td><code>AST_FUNCTION_LN</code> </td></tr>
<tr>
<td><code>AST_FUNCTION_ARCCOSH</code></td><td><code>AST_FUNCTION_LOG</code> </td></tr>
<tr>
<td><code>AST_FUNCTION_ARCCOT</code></td><td><code>AST_FUNCTION_PIECEWISE</code> </td></tr>
</table>
</center><p>There are a number of methods for interrogating the type of an ASTNode and for testing whether a node belongs to a general category of constructs. The methods are the following:</p>
<ul>
<li><code>int</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a334639306de8c7f8890e9e8ef65babb5">ASTNode.getType()</a> returns the type of this AST node. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a175527383a6dfec2ca248bf09d9f9538">ASTNode.isConstant()</a> returns <code>true</code> if this AST node is a MathML constant (<code>true</code>, <code>false</code>, <code>pi</code>, <code>exponentiale</code>), <code>false</code> otherwise. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a5eb1f13b76c1910ce9b6037649615980">ASTNode.isBoolean()</a> returns <code>true</code> if this AST node returns a boolean value (by being either a logical operator, a relational operator, or the constant <code>true</code> or <code>false</code>). </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ab8952d52f141719b7cdc49c3eb8d0648">ASTNode.isFunction()</a> returns <code>true</code> if this AST node is a function (i.e., a MathML defined function such as <code>exp</code> or else a function defined by a FunctionDefinition in the Model). </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a3b6230862c48e06fcc34196659deb263">ASTNode.isInfinity()</a> returns <code>true</code> if this AST node is the special IEEE 754 value infinity. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a05919b82a2f23bf3bb6173b5a149c45f">ASTNode.isInteger()</a> returns <code>true</code> if this AST node is holding an integer value. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#abcb2485158ec848ba3f13381b0502982">ASTNode.isNumber()</a> returns <code>true</code> if this AST node is holding any number. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a9780ce21c363f3bcb8af54776bebf13b">ASTNode.isLambda()</a> returns <code>true</code> if this AST node is a MathML <code>lambda</code> construct. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a33d7b1550ccffe184a49758e0f1ca11f">ASTNode.isLog10()</a> returns <code>true</code> if this AST node represents the <code>log10</code> function, specifically, that its type is <code>AST_FUNCTION_LOG</code> and it has two children, the first of which is an integer equal to 10. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a2eecfd2bb9f44d9d413608253ad7097b">ASTNode.isLogical()</a> returns <code>true</code> if this AST node is a logical operator (<code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>). </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ab91b48270ef61ce667b1862200ff2139">ASTNode.isName()</a> returns <code>true</code> if this AST node is a user-defined name or (in SBML Level 2) one of the two special <code>csymbol</code> constructs "delay" or "time". </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ae44187524ec31547566f20edbe1d66fe">ASTNode.isNaN()</a> returns <code>true</code> if this AST node has the special IEEE 754 value "not a number" (NaN). </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a56e06023c1a11eebb1a0fe7504c0fc76">ASTNode.isNegInfinity()</a> returns <code>true</code> if this AST node has the special IEEE 754 value of negative infinity. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ab9f871fc924296ec4e48804626b2702c">ASTNode.isOperator()</a> returns <code>true</code> if this AST node is an operator (e.g., <code>+</code>, <code>-</code>, etc.) </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a50123764f07b18ef9b174861f905c0af">ASTNode.isPiecewise()</a> returns <code>true</code> if this AST node is the MathML <code>piecewise</code> function. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a7de3c0a750973c4921cb30dc0b4b1bdb">ASTNode.isRational()</a> returns <code>true</code> if this AST node is a rational number having a numerator and a denominator. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#aef6ee8c8a5655e7c0f612cdb8241d538">ASTNode.isReal()</a> returns <code>true</code> if this AST node is a real number (specifically, <code>AST_REAL_E</code> or <code>AST_RATIONAL</code>). </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a592df485778a1bf3a2cf07a2bf223d8c">ASTNode.isRelational()</a> returns <code>true</code> if this AST node is a relational operator. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a7df65be668a409996727c0e3d96b6898">ASTNode.isSqrt()</a> returns <code>true</code> if this AST node is the square-root operator </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#af129975598726c02df8d481f75b3b9c0">ASTNode.isUMinus()</a> returns <code>true</code> if this AST node is a unary minus. </li>
<li><code>bool</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#aa199e898e60392fbd35ff13c15ec8baa">ASTNode.isUnknown()</a> returns <code>true</code> if this AST node's type is unknown.</li>
</ul>
<p>Programs manipulating AST node structures should check the type of a given node before calling methods that return a value from the node. The following meethods are available for returning values from nodes:</p>
<ul>
<li><code>int</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a39cde081cacd2f288f48d646ad389f8c">ASTNode.getInteger()</a> </li>
<li><code>char</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a2e4bdcba0173553aacef13842d862fa1">ASTNode.getCharacter()</a> </li>
<li><code>string</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a6e448fb7d18aaa5fa35ac98be1cf618c">ASTNode.getName()</a> </li>
<li><code>int</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a03a753ef626952d3b04c8535fbe31e8e">ASTNode.getNumerator()</a> </li>
<li><code>int</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a59db65cf90bb59694ef71d658945bed9">ASTNode.getDenominator()</a> </li>
<li><code>double</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a68fc0dc0898e6f8e0bfdf5d6d7a3f332">ASTNode.getReal()</a> </li>
<li><code>double</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ae31362d964eea3b91a71474d033bbfe6">ASTNode.getMantissa()</a> </li>
<li><code>int</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#aeffc67291894af59257ac475c01b77cf">ASTNode.getExponent()</a></li>
</ul>
<p>Finally (and rather predictably), libSBML provides methods for setting the values of AST nodes.</p>
<ul>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a01326ac9b59dc7df17e7d65bbefecc84">ASTNode.setCharacter(char)</a> sets the value of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> to the given character. If character is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> or <code>^</code>, the node type will be to the appropriate operator type. For all other characters, the node type will be set to <code>AST_UNKNOWN</code>. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#af735538579f8fdfe80300d401ba80b5f">ASTNode.setName(string)</a> sets the value of this AST node to the given name. The node type will be set (to <code>AST_NAME</code>) <em>only if</em> the AST node was previously an operator (<a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ab9f871fc924296ec4e48804626b2702c">isOperator()</a> <code>!= 0</code>) or number (<a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#abcb2485158ec848ba3f13381b0502982">isNumber()</a> <code>!= 0</code>). This allows names to be set for <code>AST_FUNCTIONs</code> and the like. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a9c22ebef89e4ddcca856eeb54094d6ce">ASTNode.setValue(int)</a> sets the value of the node to the given integer. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#ab942db11a7298a2658a38491a55f0ba9">ASTNode.setValue(int, int)</a> sets the value of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> to the given rational in two parts: the numerator and denominator. The node type is set to <code>AST_RATIONAL</code>. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a49f24c46a15a3324ae3e09b7c39d4edf">ASTNode.setValue(double)</a> sets the value of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> to the given floating-point number and sets the node type to <code>AST_REAL</code>. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a8739067e85f24a2749281d9528aec88d">ASTNode.setValue(double, int)</a> sets the value of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> to the given floating-point number in two parts: the mantissa and the exponent. The node type is set to <code>AST_REAL_E</code>.</li>
</ul>
<p>The following are some miscellaneous methods for manipulating ASTs:</p>
<ul>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a8694341c4e5437d49d4f767cc3dde73e">ASTNode.ASTNode(int)</a> creates a new <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> object and returns a pointer to it. The returned node will have the type identified by the code passed as the argument, or a type of <code>AST_UNKNOWN</code> if no type is explicitly given or the type code is unrecognized. </li>
<li>unsigned int <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a07c95a3d478aff0ef9895bfd0123e645">ASTNode.getNumChildren()</a> returns the number of children of this AST node or 0 is this node has no children. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#af39d1e63398ae7be5b59654b9585008a">ASTNode.addChild(ASTNode)</a> adds the given node as a child of this AST node. Child nodes are added in left-to-right order. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a77d18aeb41af8fa2d1cda1a4b030535b">ASTNode.prependChild(ASTNode)</a> adds the given node as a child of this AST node. This method adds child nodes in right-to-left order. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a6dfea6cdb8206fdda462e82adf9ec4b2">(long) ASTNode.getChild (long)</a> returns the nth child of this AST node or <code>NULL</code> if this node has no nth child (n &gt; (<a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a07c95a3d478aff0ef9895bfd0123e645">ASTNode.getNumChildren()</a> - 1)). </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#adde9a02db1a1379ea406549ab0739a33">ASTNode.getLeftChild()</a> returns the left child of this AST node. This is equivalent to <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a6dfea6cdb8206fdda462e82adf9ec4b2">ASTNode.getChild(0)</a>; </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a8b27088f3111b2b1e97572fbfe689eb9">ASTNode.getRightChild()</a> returns the right child of this AST node or <code>NULL</code> if this node has no right child. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#af1c3e94298862b0008bc8efc3910714b">ASTNode.swapChildren(ASTNode)</a> swaps the children of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> with the children of <code>that</code> <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a>. </li>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html#a2c15ee6ab7fefa082c5d856b052d2400">ASTNode.setType(int)</a> sets the type of this <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> to the type identified by the type code passed as argument, or to <code>AST_UNKNOWN</code> if the type is unrecognized.</li>
</ul>
<h1><a class="anchor" id="math-reading"></a>
Reading and Writing MathML from/to ASTs</h1>
<p>As mentioned above, applications often can avoid working with raw MathML by using either libSBML's text-string interface or the AST API. However, when needed, reading MathML content directly and creating ASTs, as well as the converse task of writing MathML, is easily done using two methods designed for this purpose:</p>
<ul>
<li><a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> <a class="el" href="classlibsbmlcs_1_1libsbml.html#aef52474edb68579004c2c76d9f89e7bd">readMathMLFromString(string)</a> reads raw MathML from a text string, constructs an AST from it, then returns the root <a class="el" href="classlibsbmlcs_1_1_a_s_t_node.html">ASTNode</a> of the resulting expression tree. </li>
<li><code>string</code> <a class="el" href="classlibsbmlcs_1_1libsbml.html#aa35a7684b9eea4e556a93b8c449ffd1f">writeMathMLToString(ASTNode)</a> writes an AST to a string. The caller owns the character string returned and should free it after it is no longer needed. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
