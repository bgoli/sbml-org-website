<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libSBML C++ API: XMLAttributes Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="libSBML C++ API"/>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="group__core.html"><span>Core&#160;libSBML</span></a></li>
      <li><a href="usergroup0.html"><span>Level&#160;3&#160;Extensions</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="libsbml-example-files.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_x_m_l_attributes.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="class_x_m_l_attributes-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">XMLAttributes Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> A list of attributes on an XML element. </p>
<p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>
<p>In libSBML's XML interface layer, attributes on an element are stored as a list of values kept in an <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> has methods for adding and removing individual attributes as well as performing other actions on the list of attributes. Classes in libSBML that represent nodes in an XML document (i.e., <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> and its parent class, <a class="el" href="class_x_m_l_token.html" title=" A token in an XML stream. ">XMLToken</a>) use <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects to manage attributes on XML elements.</p>
<p>Attributes on an XML element can be written in one of two forms: </p><ul>
<li><code>name="value"</code> </li>
<li><code>prefix:name="value"</code></li>
</ul>
<p>An attribute in XML must always have a value, and the value must always be a quoted string; i.e., it is always <code>name="value"</code> and not <code>name=value</code>. An empty value is represented simply as an empty string; i.e., <code>name=""</code>.</p>
<p>In cases when a <code>prefix</code> is provided with an attribute name, general XML validity rules require that the prefix is an XML namespace prefix that has been declared somewhere else (possibly as an another attribute on the same element). However, the <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class does <em>not</em> test for the proper existence or declaration of XML namespaces&mdash;callers must arrange to do this themselves in some other way. This class only provides facilities for tracking and manipulating attributes and their prefix/URI/name/value components.</p>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> </dd>
<dd>
<a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html" title=" A token in an XML stream. ">XMLToken</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#_a17">addingEvidenceCodes_2.cpp</a>, and <a class="el" href="create_example_s_b_m_l_8cpp-example.html#_a60">createExampleSBML.cpp</a>.</dd>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a> (const std::string &amp;name, const std::string &amp;value, const std::string namespaceURI=&quot;&quot;, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to this list of attributes.  <a href="#aa4e8d0dd27a9b619edf3766f5a87e471">More...</a><br /></td></tr>
<tr class="separator:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac244dd478625b8c31423c29d6e64e601"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601">add</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const std::string &amp;value)</td></tr>
<tr class="memdesc:ac244dd478625b8c31423c29d6e64e601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to this list of attributes.  <a href="#ac244dd478625b8c31423c29d6e64e601">More...</a><br /></td></tr>
<tr class="separator:ac244dd478625b8c31423c29d6e64e601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab841f490f96d62770359ba0f27a9444b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ab841f490f96d62770359ba0f27a9444b">clear</a> ()</td></tr>
<tr class="memdesc:ab841f490f96d62770359ba0f27a9444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all attributes in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.  <a href="#ab841f490f96d62770359ba0f27a9444b">More...</a><br /></td></tr>
<tr class="separator:ab841f490f96d62770359ba0f27a9444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffcd445b7251e72b2ad0a2c03989036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a3ffcd445b7251e72b2ad0a2c03989036">clone</a> () const </td></tr>
<tr class="memdesc:a3ffcd445b7251e72b2ad0a2c03989036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.  <a href="#a3ffcd445b7251e72b2ad0a2c03989036">More...</a><br /></td></tr>
<tr class="separator:a3ffcd445b7251e72b2ad0a2c03989036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6445564c496f1ada3ff49798530edf05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05">getIndex</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a6445564c496f1ada3ff49798530edf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of an attribute having a given name.  <a href="#a6445564c496f1ada3ff49798530edf05">More...</a><br /></td></tr>
<tr class="separator:a6445564c496f1ada3ff49798530edf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a0b66d4f07d77342b94f01ed33b8f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a10a0b66d4f07d77342b94f01ed33b8f3">getIndex</a> (const std::string &amp;name, const std::string &amp;uri) const </td></tr>
<tr class="memdesc:a10a0b66d4f07d77342b94f01ed33b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute having a given name and XML namespace URI.  <a href="#a10a0b66d4f07d77342b94f01ed33b8f3">More...</a><br /></td></tr>
<tr class="separator:a10a0b66d4f07d77342b94f01ed33b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad20b25996d4549e0a6f638b60572c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a0ad20b25996d4549e0a6f638b60572c6">getIndex</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const </td></tr>
<tr class="memdesc:a0ad20b25996d4549e0a6f638b60572c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object.  <a href="#a0ad20b25996d4549e0a6f638b60572c6">More...</a><br /></td></tr>
<tr class="separator:a0ad20b25996d4549e0a6f638b60572c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e80cc93dbbc2cf0cd70ff55ce0bb47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47">getLength</a> () const </td></tr>
<tr class="memdesc:a01e80cc93dbbc2cf0cd70ff55ce0bb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes in this list of attributes.  <a href="#a01e80cc93dbbc2cf0cd70ff55ce0bb47">More...</a><br /></td></tr>
<tr class="separator:a01e80cc93dbbc2cf0cd70ff55ce0bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cfc4a0922583a2688fecce9122d0e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ae4cfc4a0922583a2688fecce9122d0e4">getName</a> (int index) const </td></tr>
<tr class="memdesc:ae4cfc4a0922583a2688fecce9122d0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the <em>n</em>th attribute in this list of attributes.  <a href="#ae4cfc4a0922583a2688fecce9122d0e4">More...</a><br /></td></tr>
<tr class="separator:ae4cfc4a0922583a2688fecce9122d0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe503ed8bdf6f5e4f53a029ff8a27ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#acbe503ed8bdf6f5e4f53a029ff8a27ef">getNumAttributes</a> () const </td></tr>
<tr class="memdesc:acbe503ed8bdf6f5e4f53a029ff8a27ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes in this list of attributes.  <a href="#acbe503ed8bdf6f5e4f53a029ff8a27ef">More...</a><br /></td></tr>
<tr class="separator:acbe503ed8bdf6f5e4f53a029ff8a27ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5a23bafadabbbeb1355f62adf4308a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a8d5a23bafadabbbeb1355f62adf4308a">getPrefix</a> (int index) const </td></tr>
<tr class="memdesc:a8d5a23bafadabbbeb1355f62adf4308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the namespace prefix of the <em>n</em>th attribute in this attribute set.  <a href="#a8d5a23bafadabbbeb1355f62adf4308a">More...</a><br /></td></tr>
<tr class="separator:a8d5a23bafadabbbeb1355f62adf4308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be06fd61e4f34fa2df96b14642f5a08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a8be06fd61e4f34fa2df96b14642f5a08">getPrefixedName</a> (int index) const </td></tr>
<tr class="memdesc:a8be06fd61e4f34fa2df96b14642f5a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix name of the <em>n</em>th attribute in this attribute set.  <a href="#a8be06fd61e4f34fa2df96b14642f5a08">More...</a><br /></td></tr>
<tr class="separator:a8be06fd61e4f34fa2df96b14642f5a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a895d106b6a889cf970db310ccf6792"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a0a895d106b6a889cf970db310ccf6792">getURI</a> (int index) const </td></tr>
<tr class="memdesc:a0a895d106b6a889cf970db310ccf6792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace URI of the <em>n</em>th attribute in this attribute set.  <a href="#a0a895d106b6a889cf970db310ccf6792">More...</a><br /></td></tr>
<tr class="separator:a0a895d106b6a889cf970db310ccf6792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f9ed120e240be8a69e44be55c56383"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a40f9ed120e240be8a69e44be55c56383">getValue</a> (int index) const </td></tr>
<tr class="memdesc:a40f9ed120e240be8a69e44be55c56383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>n</em>th attribute in this list of attributes.  <a href="#a40f9ed120e240be8a69e44be55c56383">More...</a><br /></td></tr>
<tr class="separator:a40f9ed120e240be8a69e44be55c56383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44be2f7253ecfa6e5eb7fdb5ef83a330"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a44be2f7253ecfa6e5eb7fdb5ef83a330">getValue</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a44be2f7253ecfa6e5eb7fdb5ef83a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a named attribute's value.  <a href="#a44be2f7253ecfa6e5eb7fdb5ef83a330">More...</a><br /></td></tr>
<tr class="separator:a44be2f7253ecfa6e5eb7fdb5ef83a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1fbac803c38663734f76d40738cb64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a2f1fbac803c38663734f76d40738cb64">getValue</a> (const std::string &amp;name, const std::string &amp;uri) const </td></tr>
<tr class="memdesc:a2f1fbac803c38663734f76d40738cb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a named attribute's value.  <a href="#a2f1fbac803c38663734f76d40738cb64">More...</a><br /></td></tr>
<tr class="separator:a2f1fbac803c38663734f76d40738cb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a0086c0b8f6447b74cb6f533d32153"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a95a0086c0b8f6447b74cb6f533d32153">getValue</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const </td></tr>
<tr class="memdesc:a95a0086c0b8f6447b74cb6f533d32153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of an attribute described by a given <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object.  <a href="#a95a0086c0b8f6447b74cb6f533d32153">More...</a><br /></td></tr>
<tr class="separator:a95a0086c0b8f6447b74cb6f533d32153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f18957a07a747876a84431915b92f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1">hasAttribute</a> (int index) const </td></tr>
<tr class="memdesc:a76f18957a07a747876a84431915b92f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute exists at a given index.  <a href="#a76f18957a07a747876a84431915b92f1">More...</a><br /></td></tr>
<tr class="separator:a76f18957a07a747876a84431915b92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa101bbde673dd99f68ef0b5fee483def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa101bbde673dd99f68ef0b5fee483def">hasAttribute</a> (const std::string &amp;name, const std::string uri=&quot;&quot;) const </td></tr>
<tr class="memdesc:aa101bbde673dd99f68ef0b5fee483def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with a given name and namespace URI exists.  <a href="#aa101bbde673dd99f68ef0b5fee483def">More...</a><br /></td></tr>
<tr class="separator:aa101bbde673dd99f68ef0b5fee483def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabcc48288b4fc697884e8137223ae31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31">hasAttribute</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const </td></tr>
<tr class="memdesc:aaabcc48288b4fc697884e8137223ae31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with the given properties exists.  <a href="#aaabcc48288b4fc697884e8137223ae31">More...</a><br /></td></tr>
<tr class="separator:aaabcc48288b4fc697884e8137223ae31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26896f4b9a5b411f6c86020c6045dc2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a26896f4b9a5b411f6c86020c6045dc2c">isEmpty</a> () const </td></tr>
<tr class="memdesc:a26896f4b9a5b411f6c86020c6045dc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this list of attributes is empty.  <a href="#a26896f4b9a5b411f6c86020c6045dc2c">More...</a><br /></td></tr>
<tr class="separator:a26896f4b9a5b411f6c86020c6045dc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044f9a1f9c37123e8a185df1600abc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a4044f9a1f9c37123e8a185df1600abc9">operator=</a> (const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4044f9a1f9c37123e8a185df1600abc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a>.  <a href="#a4044f9a1f9c37123e8a185df1600abc9">More...</a><br /></td></tr>
<tr class="separator:a4044f9a1f9c37123e8a185df1600abc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739f7f54c97e39f4720d777289e162bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a739f7f54c97e39f4720d777289e162bf">readInto</a> (const std::string &amp;name, bool &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a739f7f54c97e39f4720d777289e162bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a Boolean value.  <a href="#a739f7f54c97e39f4720d777289e162bf">More...</a><br /></td></tr>
<tr class="separator:a739f7f54c97e39f4720d777289e162bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa447b61a4c289c15b9ca9cff65e1a347"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa447b61a4c289c15b9ca9cff65e1a347">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, bool &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:aa447b61a4c289c15b9ca9cff65e1a347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a Boolean value.  <a href="#aa447b61a4c289c15b9ca9cff65e1a347">More...</a><br /></td></tr>
<tr class="separator:aa447b61a4c289c15b9ca9cff65e1a347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f2791071126433398f9b440c75db3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ab65f2791071126433398f9b440c75db3">readInto</a> (const std::string &amp;name, double &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:ab65f2791071126433398f9b440c75db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>double</code> value.  <a href="#ab65f2791071126433398f9b440c75db3">More...</a><br /></td></tr>
<tr class="separator:ab65f2791071126433398f9b440c75db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa396834ca5a3c2b69500464b62c3754f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa396834ca5a3c2b69500464b62c3754f">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, double &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:aa396834ca5a3c2b69500464b62c3754f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>double</code> value.  <a href="#aa396834ca5a3c2b69500464b62c3754f">More...</a><br /></td></tr>
<tr class="separator:aa396834ca5a3c2b69500464b62c3754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd01a04238a79814e19428deb731061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a2fd01a04238a79814e19428deb731061">readInto</a> (const std::string &amp;name, long &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a2fd01a04238a79814e19428deb731061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>long</code> integer value.  <a href="#a2fd01a04238a79814e19428deb731061">More...</a><br /></td></tr>
<tr class="separator:a2fd01a04238a79814e19428deb731061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec0988d526c669b7cb240e4b1920500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aeec0988d526c669b7cb240e4b1920500">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, long &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:aeec0988d526c669b7cb240e4b1920500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>long</code> integer value.  <a href="#aeec0988d526c669b7cb240e4b1920500">More...</a><br /></td></tr>
<tr class="separator:aeec0988d526c669b7cb240e4b1920500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4727511c5d8c62c5010accfc1e59d34f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a4727511c5d8c62c5010accfc1e59d34f">readInto</a> (const std::string &amp;name, int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a4727511c5d8c62c5010accfc1e59d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>int</code> value.  <a href="#a4727511c5d8c62c5010accfc1e59d34f">More...</a><br /></td></tr>
<tr class="separator:a4727511c5d8c62c5010accfc1e59d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee6cf5316f6d7fe218acc87fb569f7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#acee6cf5316f6d7fe218acc87fb569f7a">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:acee6cf5316f6d7fe218acc87fb569f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>int</code> value.  <a href="#acee6cf5316f6d7fe218acc87fb569f7a">More...</a><br /></td></tr>
<tr class="separator:acee6cf5316f6d7fe218acc87fb569f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef6ec66246aba0176039d71d63731df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a0ef6ec66246aba0176039d71d63731df">readInto</a> (const std::string &amp;name, unsigned int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a0ef6ec66246aba0176039d71d63731df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>unsigned int</code> value.  <a href="#a0ef6ec66246aba0176039d71d63731df">More...</a><br /></td></tr>
<tr class="separator:a0ef6ec66246aba0176039d71d63731df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e214d2380bca266f6e2cd2ba4cc75f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a03e214d2380bca266f6e2cd2ba4cc75f">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, unsigned int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a03e214d2380bca266f6e2cd2ba4cc75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>unsigned int</code> value.  <a href="#a03e214d2380bca266f6e2cd2ba4cc75f">More...</a><br /></td></tr>
<tr class="separator:a03e214d2380bca266f6e2cd2ba4cc75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe7ad8d107bb01183f0ea426164e0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#adbfe7ad8d107bb01183f0ea426164e0e">readInto</a> (const std::string &amp;name, std::string &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:adbfe7ad8d107bb01183f0ea426164e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a string value.  <a href="#adbfe7ad8d107bb01183f0ea426164e0e">More...</a><br /></td></tr>
<tr class="separator:adbfe7ad8d107bb01183f0ea426164e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b7019532c1adb88e3bef82e77feadc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a28b7019532c1adb88e3bef82e77feadc">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, std::string &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const </td></tr>
<tr class="memdesc:a28b7019532c1adb88e3bef82e77feadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a string value.  <a href="#a28b7019532c1adb88e3bef82e77feadc">More...</a><br /></td></tr>
<tr class="separator:a28b7019532c1adb88e3bef82e77feadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba7c7900c10a809b4d14aec7344fd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1">remove</a> (int n)</td></tr>
<tr class="memdesc:a92ba7c7900c10a809b4d14aec7344fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <em>n</em>th attribute from this list of attributes.  <a href="#a92ba7c7900c10a809b4d14aec7344fd1">More...</a><br /></td></tr>
<tr class="separator:a92ba7c7900c10a809b4d14aec7344fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93f0fb0bb2933afd40264d23fea4a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aca93f0fb0bb2933afd40264d23fea4a7">remove</a> (const std::string &amp;name, const std::string uri=&quot;&quot;)</td></tr>
<tr class="memdesc:aca93f0fb0bb2933afd40264d23fea4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a named attribute from this list of attributes.  <a href="#aca93f0fb0bb2933afd40264d23fea4a7">More...</a><br /></td></tr>
<tr class="separator:aca93f0fb0bb2933afd40264d23fea4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807cc84ce5e1d372af5dbf3404815f9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b">remove</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple)</td></tr>
<tr class="memdesc:a807cc84ce5e1d372af5dbf3404815f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific attribute from this list of attributes.  <a href="#a807cc84ce5e1d372af5dbf3404815f9b">More...</a><br /></td></tr>
<tr class="separator:a807cc84ce5e1d372af5dbf3404815f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a> ()</td></tr>
<tr class="memdesc:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, empty <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.  <a href="#aeb85120c7a1a43e65e35efeba8bef6ad">More...</a><br /></td></tr>
<tr class="separator:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a6cfc9deeaac1b011a509e96b33ed5d02">XMLAttributes</a> (const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;orig)</td></tr>
<tr class="memdesc:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.  <a href="#a6cfc9deeaac1b011a509e96b33ed5d02">More...</a><br /></td></tr>
<tr class="separator:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666cf3d31b17e758424c7cbbfc77ac22"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a666cf3d31b17e758424c7cbbfc77ac22">~XMLAttributes</a> ()</td></tr>
<tr class="memdesc:a666cf3d31b17e758424c7cbbfc77ac22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.  <a href="#a666cf3d31b17e758424c7cbbfc77ac22">More...</a><br /></td></tr>
<tr class="separator:a666cf3d31b17e758424c7cbbfc77ac22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb85120c7a1a43e65e35efeba8bef6ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::XMLAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new, empty <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </p>

</div>
</div>
<a class="anchor" id="a666cf3d31b17e758424c7cbbfc77ac22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::~XMLAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </p>

</div>
</div>
<a class="anchor" id="a6cfc9deeaac1b011a509e96b33ed5d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::XMLAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </p>
<p><code>orig</code> the <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object to copy. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa4e8d0dd27a9b619edf3766f5a87e471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>namespaceURI</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an attribute to this list of attributes. </p>
<dl class="section user"><dt></dt><dd>Some explanations are in order about the behavior of <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> with respect to namespace prefixes and namespace URIs. <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> does <em>not</em> verify the consistency of different uses of an XML namespace and the prefix used to refer to it in a given context. It cannot, because the prefix used for a given XML namespace in an XML document may intentionally be different on different elements in the document. Consequently, callers need to manage their own prefix-to-namespace mappings, and need to ensure that the desired prefix is used in any given context.</dd></dl>
<p>When called with attribute names, prefixes and namespace URIs, <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> pays attention to the namespace URIs and not the prefixes: a match is established by a combination of attribute name and namespace URI, and if on different occasions a different prefix is used for the same name/namespace combination, the prefix associated with the namespace on that attribute is overwritten.</p>
<p>Some examples will hopefully clarify this. Here are the results of a sequence of calls to the <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> <code>add</code> methods with different argument combinations. First, we create the object and add one attribute:</p>
<div class="fragment"><div class="line"><a class="code" href="class_x_m_l_attributes.html">XMLAttributes</a> * att = <span class="keyword">new</span> <a class="code" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a>();</div><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div></div><!-- fragment --><p> The above adds an attribute named <code>myattribute</code> in the namespace <code>myuri</code>, and with the attribute value <code>1</code>. No namespace prefix is associated with the attribute (but the attribute is recorded to exist in the namespace <code>myuri</code>). If this attribute object were written out in XML, it would look like the following (and note that, since no namespace prefix was assigned, none is written out): </p><center><pre>
myattribute="1"
   </pre></center><p>Continuing with this series of examples, suppose we invoke the <code>add</code> method again as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div></div><!-- fragment --><p> The above adds a <em>new</em> attribute <em>also</em> named <code>myattribute</code>, but in a different XML namespace: it is placed in the namespace with no URI, which is to say, the default XML namespace. Both attributes coexist on this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object; both can be independently retrieved.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div></div><!-- fragment --><p> The code above now replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. The attribute in the namespace <code>myuri</code> remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. The attribute in the default namespace remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also now assigns a namespace prefix, <code>foo</code>, to the attribute. The attribute <code>myattribute</code> in the default namespace remains untouched. If this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
myattribute="3"
foo:myattribute="5"
   </pre></center><p> Pressing on, now suppose we call the <code>add</code> method as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also assigns a different prefix to the attribute. The namespace of the attribute remains <code>myuri</code>.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div></div><!-- fragment --><p>The code above replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. It also now assigns a namespace prefix, <code>foo</code>, to that attribute. If this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
bar:myattribute="6"
foo:myattribute="7"
   </pre></center><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute. </td></tr>
    <tr><td class="paramname">value</td><td>a string, the value of the attribute. </td></tr>
    <tr><td class="paramname">namespaceURI</td><td>a string, the namespace URI of the attribute. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string, a prefix for the XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> &ndash; this value is returned if any of the arguments are <code>NULL</code>. To set an empty <code>prefix</code> and/or <code>name</code> value, use an empty string rather than <code>NULL</code>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists in the list of attributes held by this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, then the previous value of that attribute will be replaced with the new value provided to this method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes. ">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a10a0b66d4f07d77342b94f01ed33b8f3" title="Returns the index of the attribute having a given name and XML namespace URI. ">getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a0ad20b25996d4549e0a6f638b60572c6" title="Returns the index of the attribute defined by the given XMLTriple object. ">getIndex(const XMLTriple&amp; triple) const</a> </dd>
<dd>
hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a22">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac244dd478625b8c31423c29d6e64e601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an attribute to this list of attributes. </p>
<dl class="section user"><dt></dt><dd>Some explanations are in order about the behavior of <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> with respect to namespace prefixes and namespace URIs. <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> does <em>not</em> verify the consistency of different uses of an XML namespace and the prefix used to refer to it in a given context. It cannot, because the prefix used for a given XML namespace in an XML document may intentionally be different on different elements in the document. Consequently, callers need to manage their own prefix-to-namespace mappings, and need to ensure that the desired prefix is used in any given context.</dd></dl>
<p>When called with attribute names, prefixes and namespace URIs, <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> pays attention to the namespace URIs and not the prefixes: a match is established by a combination of attribute name and namespace URI, and if on different occasions a different prefix is used for the same name/namespace combination, the prefix associated with the namespace on that attribute is overwritten.</p>
<p>Some examples will hopefully clarify this. Here are the results of a sequence of calls to the <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> <code>add</code> methods with different argument combinations. First, we create the object and add one attribute:</p>
<div class="fragment"><div class="line"><a class="code" href="class_x_m_l_attributes.html">XMLAttributes</a> * att = <span class="keyword">new</span> <a class="code" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a>();</div><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div></div><!-- fragment --><p> The above adds an attribute named <code>myattribute</code> in the namespace <code>myuri</code>, and with the attribute value <code>1</code>. No namespace prefix is associated with the attribute (but the attribute is recorded to exist in the namespace <code>myuri</code>). If this attribute object were written out in XML, it would look like the following (and note that, since no namespace prefix was assigned, none is written out): </p><center><pre>
myattribute="1"
   </pre></center><p>Continuing with this series of examples, suppose we invoke the <code>add</code> method again as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div></div><!-- fragment --><p> The above adds a <em>new</em> attribute <em>also</em> named <code>myattribute</code>, but in a different XML namespace: it is placed in the namespace with no URI, which is to say, the default XML namespace. Both attributes coexist on this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object; both can be independently retrieved.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div></div><!-- fragment --><p> The code above now replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. The attribute in the namespace <code>myuri</code> remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. The attribute in the default namespace remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also now assigns a namespace prefix, <code>foo</code>, to the attribute. The attribute <code>myattribute</code> in the default namespace remains untouched. If this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
myattribute="3"
foo:myattribute="5"
   </pre></center><p> Pressing on, now suppose we call the <code>add</code> method as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div></div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also assigns a different prefix to the attribute. The namespace of the attribute remains <code>myuri</code>.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div></div><!-- fragment --><p>The code above replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. It also now assigns a namespace prefix, <code>foo</code>, to that attribute. If this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
bar:myattribute="6"
foo:myattribute="7"
   </pre></center><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute to be added. </td></tr>
    <tr><td class="paramname">value</td><td>a string, the value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> &ndash; this value is returned if any of the arguments are <code>NULL</code>. To set an empty value for the attribute, use an empty string rather than <code>NULL</code>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists in the list of attributes held by this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, then the previous value of that attribute will be replaced with the new value provided to this method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a10a0b66d4f07d77342b94f01ed33b8f3" title="Returns the index of the attribute having a given name and XML namespace URI. ">getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a0ad20b25996d4549e0a6f638b60572c6" title="Returns the index of the attribute defined by the given XMLTriple object. ">getIndex(const XMLTriple&amp; triple) const</a> </dd>
<dd>
hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab841f490f96d62770359ba0f27a9444b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all attributes in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes. ">remove(int n)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes. ">remove(const XMLTriple&amp; triple)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a21">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3ffcd445b7251e72b2ad0a2c03989036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> * XMLAttributes::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6445564c496f1ada3ff49798530edf05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of an attribute having a given name. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not check XML namespaces. Thus, if there are multiple attributes with the same local <code>name</code> but different namespaces, this method will return the first one found. Callers should use the more specific methods <a class="el" href="class_x_m_l_attributes.html#a10a0b66d4f07d77342b94f01ed33b8f3" title="Returns the index of the attribute having a given name and XML namespace URI. ">XMLAttributes::getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> or <a class="el" href="class_x_m_l_attributes.html#a0ad20b25996d4549e0a6f638b60572c6" title="Returns the index of the attribute defined by the given XMLTriple object. ">XMLAttributes::getIndex(const XMLTriple&amp; triple) const</a> to find attributes in particular namespaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute whose index is begin sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given local name, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10a0b66d4f07d77342b94f01ed33b8f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the attribute having a given name and XML namespace URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute being sought. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the namespace URI of the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given local name and namespace URI, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad20b25996d4549e0a6f638b60572c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> describing the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute described by the given <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01e80cc93dbbc2cf0cd70ff55ce0bb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of attributes in this list of attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of attributes contained in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4cfc4a0922583a2688fecce9122d0e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the <em>n</em>th attribute in this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local name of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acbe503ed8bdf6f5e4f53a029ff8a27ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getNumAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of attributes in this list of attributes. </p>
<p>This function is merely an alias of <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> introduced for consistency with other libXML classes.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of attributes contained in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d5a23bafadabbbeb1355f62adf4308a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getPrefix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the namespace prefix of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose namespace prefix is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace prefix of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8be06fd61e4f34fa2df96b14642f5a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getPrefixedName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the prefix name of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose prefixed name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the prefixed name of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a895d106b6a889cf970db310ccf6792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getURI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the XML namespace URI of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose namespace URI is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace URI of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a40f9ed120e240be8a69e44be55c56383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the <em>n</em>th attribute in this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML value of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a76f18957a07a747876a84431915b92f1" title="Returns true if an attribute exists at a given index. ">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44be2f7253ecfa6e5eb7fdb5ef83a330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a named attribute's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the given local <code>name</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence. This method also does not check the XML namespace of the named attribute. Thus, if there are multiple attributes with the same local <code>name</code> but different namespaces, this method will return the value of the first such attribute found. Callers should use the more specific methods <a class="el" href="class_x_m_l_attributes.html#a10a0b66d4f07d77342b94f01ed33b8f3" title="Returns the index of the attribute having a given name and XML namespace URI. ">XMLAttributes::getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> or <a class="el" href="class_x_m_l_attributes.html#a0ad20b25996d4549e0a6f638b60572c6" title="Returns the index of the attribute defined by the given XMLTriple object. ">XMLAttributes::getIndex(const XMLTriple&amp; triple) const </a>to find attributes in particular namespaces.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2f1fbac803c38663734f76d40738cb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a named attribute's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute whose value is being sought. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the given <code>name</code> and namespace <code>uri</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95a0086c0b8f6447b74cb6f533d32153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of an attribute described by a given <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> describing the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the properties given by <code>triple</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aaabcc48288b4fc697884e8137223ae31" title="Returns true if an attribute with the given properties exists. ">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76f18957a07a747876a84431915b92f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute exists at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given index exists in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream. </dd></dl>

</div>
</div>
<a class="anchor" id="aa101bbde673dd99f68ef0b5fee483def"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with a given name and namespace URI exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given local name and XML namespace URI exists in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes. ">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaabcc48288b4fc697884e8137223ae31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with the given properties exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> describing the attribute to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given XML triple exists in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes. ">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26896f4b9a5b411f6c86020c6045dc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this list of attributes is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4044f9a1f9c37123e8a185df1600abc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp; XMLAttributes::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a739f7f54c97e39f4720d777289e162bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a Boolean value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a Boolean. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a Boolean, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#boolean" target="_blank">XML Schema</a>, the valid Boolean values are: <code>"true"</code>, <code>"false"</code>, <code>"1"</code>, and <code>"0"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a Boolean, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a Boolean, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa447b61a4c289c15b9ca9cff65e1a347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a Boolean value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a Boolean. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a Boolean, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#boolean" target="_blank">XML Schema</a>, the valid Boolean values are: <code>"true"</code>, <code>"false"</code>, <code>"1"</code>, and <code>"0"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a Boolean, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute to read.</td></tr>
    <tr><td class="paramname">value</td><td>a Boolean, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab65f2791071126433398f9b440c75db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>double</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a <code>double</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>double</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#double" target="_blank">XML Schema</a>, valid doubles are the same as valid doubles for the C language and in addition, the special values <code>"INF"</code>, <code>"-INF"</code>, and <code>"NaN"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>double</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>double</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="aa396834ca5a3c2b69500464b62c3754f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>double</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a <code>double</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>double</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#double" target="_blank">XML Schema</a>, valid doubles are the same as valid doubles for the C language and in addition, the special values <code>"INF"</code>, <code>"-INF"</code>, and <code>"NaN"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>double</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute to read.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>double</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fd01a04238a79814e19428deb731061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>long</code> integer value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a <code>long</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>long</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. This is unfortunately a larger space of values than can be represented in a long integer, so libSBML limits the possible values to those that can be stored in a <code>long</code> data type.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>long</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="aeec0988d526c669b7cb240e4b1920500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>long</code> integer value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as a <code>long</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>long</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. This is unfortunately a larger space of values than can be represented in a long, so libSBML limits the possible values to those that can be stored in a <code>long</code> data type.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>a <code>long</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a4727511c5d8c62c5010accfc1e59d34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>int</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as an <code>int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as signed <code>int</code> values and cannot represent larger values. Note that variant methods on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> are available to work with <code>unsigned int</code> type and <code>long</code> type values; users may wish to investigate those methods if they need to handle larger integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="acee6cf5316f6d7fe218acc87fb569f7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>int</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as an <code>int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as signed <code>int</code> values and cannot represent larger values. Note that variant methods on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> are available to work with <code>unsigned int</code> type and <code>long</code> type values; users may wish to investigate those methods if they need to handle larger integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ef6ec66246aba0176039d71d63731df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>unsigned int</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as an <code>unsigned int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>unsigned int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as <code>unsigned int</code> and cannot represent larger values. Note that a variant method on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> is available to work with <code>long</code> type values; users may wish to investigate that method if they need to handle large integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a03e214d2380bca266f6e2cd2ba4cc75f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>unsigned int</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and attempts to interpret it as an <code>unsigned int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>unsigned int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as <code>unsigned int</code> and cannot represent larger values. Note that a variant method on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> is available to work with <code>long</code> type values; users may wish to investigate that method if they need to handle large integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adbfe7ad8d107bb01183f0ea426164e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a string value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, <code>value</code> is left unmodified.</p>
<p>Unlike the other variant methods on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a>, there are no format errors possible when reading strings, since XML attribute values <em>are</em> strings. However, the case of a missing attribute can still occur. Errors will be logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a string, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a6445564c496f1ada3ff49798530edf05" title="Returns the index of an attribute having a given name. ">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a28b7019532c1adb88e3bef82e77feadc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a string value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object and stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object, <code>value</code> is left unmodified.</p>
<p>Unlike the other variant methods on <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a>, there are no format errors possible when reading strings, since XML attribute values <em>are</em> strings. However, the case of a missing attribute can still occur. Errors will be logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>a string, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html" title=" Log of diagnostics reported during XML processing. ">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a92ba7c7900c10a809b4d14aec7344fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <em>n</em>th attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer the index of the resource to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute at the given index <code>n</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html" title=" A list of attributes on an XML element. ">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a01e80cc93dbbc2cf0cd70ff55ce0bb47" title="Returns the number of attributes in this list of attributes. ">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes. ">remove(const XMLTriple&amp; triple)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>

</div>
</div>
<a class="anchor" id="aca93f0fb0bb2933afd40264d23fea4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a named attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute to be removed.</td></tr>
    <tr><td class="paramname">uri</td><td>a string, the namespace URI of the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute with the given <code>name</code> (and <code>uri</code> if specified).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes. ">remove(int n)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes. ">remove(const XMLTriple&amp; triple)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a807cc84ce5e1d372af5dbf3404815f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a specific attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html" title=" A qualified XML name. ">XMLTriple</a> describing the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute matching the properties of the given <code>triple</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes. ">remove(int n)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
