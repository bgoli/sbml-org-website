<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libSBML C API: ASTNode_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="libSBML C API"/>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C API
   &#160;<span id="projectnumber">5.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="group__core.html"><span>Core&#160;libSBML</span></a></li>
      <li><a href="usergroup0.html"><span>Level&#160;3&#160;Extensions</span></a></li>
      <li class="current"><a href="annotated.html"><span>Structures,&#160;functions</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="libsbml-example-files-c.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Functions</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_a_s_t_node__t.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">ASTNode_t Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> Abstract Syntax Tree (AST) representation of a mathematical expression. </p>
<p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>
<p>Abstract Syntax Trees (ASTs) are a simple kind of data structure used in libSBML for storing mathematical expressions. The <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> is the cornerstone of libSBML's AST representation. An AST "node" represents the most basic, indivisible part of a mathematical formula and come in many types. For instance, there are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. LibSBML ASTs provide a canonical, in-memory representation for all mathematical formulas regardless of their original format (which might be MathML or might be text strings).</p>
<dl class="section user"><dt></dt><dd>An AST <em>node</em> in libSBML is a recursive tree structure; each node has a type, a pointer to a value, and a list of children nodes. Each <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> node may have none, one, two, or more children depending on its type. There are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. The following diagram illustrates an example of how the mathematical expression <code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node having two <em>integer</em> children nodes for the numbers <code>1</code> and <code>2</code>. The figure also shows the corresponding MathML representation:</dd></dl>
<table border="0" class="centered text-table width80 normal-font" style="padding-bottom: 0.5em">
<caption class="top-caption">Example AST representation of a mathematical expression.</caption>
<tr>
<th width="50px">Infix</th>
<th>AST</th>
<th>MathML</th>
</tr>
<tr>
<td valign="middle" align="center">
<code>1 + 2</code>
</td>
<td valign="middle">
  <object type="image/svg+xml" data="simple-ast.svg" class="centered" width="140px"></object>
</td>
<td valign="middle">
<code>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;</code><br>
<code>&nbsp;&nbsp;&lt;apply&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;plus/&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 1 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 2 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&lt;/apply&gt;</code><br>
<code>&lt;/math&gt;</code>
</td>
</tr>
</table>
<p>The following are other noteworthy points about the AST representation in libSBML:</p>
<ul>
<li>A numerical value represented in MathML as a real number with an exponent is preserved as such in the AST node representation, even if the number could be stored in a <code>double</code> data type. This is done so that when an SBML model is read in and then written out again, the amount of change introduced by libSBML to the SBML during the round-trip activity is minimized.</li>
</ul>
<ul>
<li>Rational numbers are represented in an AST node using separate numerator and denominator values. These can be retrieved using the methods ASTNode_t::getNumerator() and ASTNode_t::getDenominator().</li>
</ul>
<ul>
<li>The children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> are other <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> objects. The list of children is empty for nodes that are leaf elements, such as numbers. For nodes that are actually roots of expression subtrees, the list of children points to the parsed objects that make up the rest of the expression.</li>
</ul>
<p>For many applications, the details of ASTs are irrelevant because libSBML provides text-string based translation functions such as <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> and <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a>. If you find the complexity of using the AST representation of expressions too high for your purposes, perhaps the string-based functions will be more suitable.</p>
<h3><a class="anchor" id="ASTNodeType_t"></a> ASTNodeType_t</h3>
<dl class="section user"><dt></dt><dd>Every <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> has an associated type code to indicate whether, for example, it holds a number or stands for an arithmetic operator. The type is recorded as a value drawn from the enumeration <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode_ttypes. ">ASTNodeType_t</a>. The list of possible types is quite long, because it covers all the mathematical functions that are permitted in SBML. The values are shown in the following table:</dd></dl>
<table border="0" class="centered text-table align-bottom borderless code">
<tr><td>AST_CONSTANT_E</td><td>         AST_FUNCTION_CSC</td><td>                       AST_LOGICAL_AND</td></tr>
<tr><td>AST_CONSTANT_FALSE</td><td>     AST_FUNCTION_CSCH</td><td>                      AST_LOGICAL_IMPLIES<sup>2</sup></td></tr>
<tr><td>AST_CONSTANT_PI</td><td>        AST_FUNCTION_DELAY</td><td>                     AST_LOGICAL_NOT</td></tr>
<tr><td>AST_CONSTANT_TRUE</td><td>      AST_FUNCTION_EXP</td><td>                       AST_LOGICAL_OR</td></tr>
<tr><td>AST_DIVIDE</td><td>             AST_FUNCTION_FACTORIAL</td><td>                 AST_LOGICAL_XOR</td></tr>
<tr><td>AST_FUNCTION</td><td>           AST_FUNCTION_FLOOR</td><td>                     AST_MINUS</td></tr>
<tr><td>AST_FUNCTION_ABS</td><td>       AST_FUNCTION_LN</td><td>                        AST_NAME</td></tr>
<tr><td>AST_FUNCTION_ARCCOS</td><td>    AST_FUNCTION_LOG</td><td>                       AST_NAME_AVOGADRO<sup>1</sup></td></tr>
<tr><td>AST_FUNCTION_ARCCOSH</td><td>   AST_FUNCTION_MAX<sup>2</sup></td><td>           AST_NAME_TIME</td></tr>
<tr><td>AST_FUNCTION_ARCCOT</td><td>    AST_FUNCTION_MIN<sup>2</sup></td><td>           AST_ORIGINATES_IN_PACKAGE<sup>2</sup></tr>
<tr><td>AST_FUNCTION_ARCCOTH</td><td>   AST_FUNCTION_PIECEWISE</td><td>                 AST_PLUS</td></tr>
<tr><td>AST_FUNCTION_ARCCSC</td><td>    AST_FUNCTION_POWER</td><td>                     AST_POWER</td></tr>
<tr><td>AST_FUNCTION_ARCCSCH</td><td>   AST_FUNCTION_QUOTIENT<sup>2</sup></td><td>      AST_RATIONAL</td></tr>
<tr><td>AST_FUNCTION_ARCSEC</td><td>    AST_FUNCTION_RATE_OF<sup>2</sup></td><td>       AST_REAL</td></tr>
<tr><td>AST_FUNCTION_ARCSECH</td><td>   AST_FUNCTION_REM<sup>2</sup></td><td>           AST_REAL_E</td></tr>
<tr><td>AST_FUNCTION_ARCSIN</td><td>    AST_FUNCTION_ROOT</td><td>                      AST_RELATIONAL_EQ</td></tr>
<tr><td>AST_FUNCTION_ARCSINH</td><td>   AST_FUNCTION_SEC</td><td>                       AST_RELATIONAL_GEQ</td></tr>
<tr><td>AST_FUNCTION_ARCTAN</td><td>    AST_FUNCTION_SECH</td><td>                      AST_RELATIONAL_GT</td></tr>
<tr><td>AST_FUNCTION_ARCTANH</td><td>   AST_FUNCTION_SIN</td><td>                       AST_RELATIONAL_LEQ</td></tr>
<tr><td>AST_FUNCTION_CEILING</td><td>   AST_FUNCTION_SINH</td><td>                      AST_RELATIONAL_LT</td></tr>
<tr><td>AST_FUNCTION_COS</td><td>       AST_FUNCTION_TAN</td><td>                       AST_RELATIONAL_NEQ</td></tr>
<tr><td>AST_FUNCTION_COSH</td><td>      AST_FUNCTION_TANH</td><td>                      AST_TIMES</td></tr>
<tr><td>AST_FUNCTION_COT</td><td>       AST_INTEGER</td><td>                            AST_UNKNOWN</td></tr>
<tr><td>AST_FUNCTION_COTH</td><td>      AST_LAMBDA</td></tr>
<tr><td><sup>1</sup> <span class='warning'><em>(Level&nbsp;3 only)</em></span><br/></td></tr>
<tr><td><sup>2</sup> <span class='warning'><em>(Level&nbsp;3 Version&nbsp;2+ only)</em></span></td></tr>
</table>


<p>The types have the following meanings:</p>
<ul>
<li>If the node is basic mathematical operator (e.g., <code>"+"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b5febe16514530ccf97536c0a26244d">AST_TIMES</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a11408698b7be79184ba65779128ef654">AST_DIVIDE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203abfa0a5d49f1a260bab7663cf688e76a9">AST_POWER</a>, as appropriate.</li>
</ul>
<ul>
<li>If the node is a predefined function or operator from SBML Level&#160;1 (in the string-based formula syntax used in Level&#160;1) or SBML Level&#160;2 and&#160;3 (in the subset of MathML used in SBML Levels&#160;2 and&#160;3), then the node's type will be either <code style="margin-right: 0">AST_FUNCTION_</code><span class="placeholder-nospace">X</span>, <code style="margin-right: 0">AST_LOGICAL_</code><span class="placeholder-nospace">X</span>, or <code style="margin-right: 0">AST_RELATIONAL_</code><span class="placeholder-nospace">X</span>, as appropriate. (Examples: <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aee5ce31deca83c9d96a5888474bc0e4d">AST_FUNCTION_LOG</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aaa8b4b6cb64685254887b5a6fe81678f">AST_RELATIONAL_LEQ</a>.)</li>
</ul>
<ul>
<li>If the node refers to a user-defined function, the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> (because it holds the name of the function).</li>
</ul>
<ul>
<li>If the node is a lambda expression, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>.</li>
</ul>
<ul>
<li>If the node is a predefined constant (<code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adb591fa008acf014bc037d95a6a89a69">AST_CONSTANT_E</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa94de3fb689270170a756ed428b253f6">AST_CONSTANT_PI</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ad571d2b80f4dcc08fc489960efdb2ab3">AST_CONSTANT_TRUE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adc46a568eb6b891f72738b67da24347a">AST_CONSTANT_FALSE</a>.</li>
</ul>
<ul>
<li>(Levels&#160;2 and&#160;3 only) If the node is the special MathML csymbol <code>time</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a0358231b02f7964269ebb2e580defdf2">AST_NAME_TIME</a>. (Note, however, that the MathML csymbol <code>delay</code> is translated into a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1e338a4da69ff5894213bd14a3b46b91">AST_FUNCTION_DELAY</a>. The difference is due to the fact that <code>time</code> is a single variable, whereas <code>delay</code> is actually a function taking arguments.)</li>
</ul>
<ul>
<li>(Level&#160;3 only) If the node is the special MathML csymbol <code>avogadro</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is the special MathML csymbol <code>rateOf</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aedbf4bf10b748da0f71f05c1ea99080f">AST_FUNCTION_RATE_OF</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is a MathML operator that originates in a package, it is included in the ASTNodeType_t list, but may not be legally used in an SBML document that does not include that package. This includes the node types from the 'Distributions' package (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1fc325768aee9f59a93ef090eb7dc4c9">AST_DISTRIB_FUNCTION_NORMAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4ecce7aa854c8573fa6a4d5dc1a4701c">AST_DISTRIB_FUNCTION_UNIFORM</a>, etc.), and elements from MathML that were not included in core.</li>
</ul>
<ul>
<li>If the node contains a numerical value, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, as appropriate.</li>
</ul>
<h3><a class="anchor" id="math-convert"></a>Converting between ASTs and text strings</h3>
<p>The text-string form of mathematical formulas produced by <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and read by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> and <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> are in a simple C-inspired infix notation. A formula in this text-string form can be handed to a program that understands SBML mathematical expressions, or used as part of a translation system. The libSBML distribution comes with an example program in the <code>"examples"</code> subdirectory called <code>translateMath</code> that implements an interactive command-line demonstration of translating infix formulas into MathML and vice-versa.</p>
<p>The formula strings may contain operators, function calls, symbols, and white space characters. The allowable white space characters are tab and space. The following are illustrative examples of formulas expressed in the syntax:</p>
<pre class="fragment">0.10 * k4^2
</pre> <pre class="fragment">(vm * s1)/(km + s1)
</pre><p>The following table shows the precedence rules in this syntax. In the Class column, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the Precedence column show how the order of different types of operation are determined. For example, the expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em> because the <code>*</code> operator has higher precedence. The Associates column shows how the order of similar precedence operations is determined; for example, <em>a - b + c</em> is evaluated as <em>(a - b) + c</em> because the <code>+</code> and <code>-</code> operators are left-associative. The precedence and associativity rules are taken from the C programming language, except for the symbol <code>^</code>, which is used in C for a different purpose. (Exponentiation can be invoked using either <code>^</code> or the function <code>power</code>.)</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>A program parsing a formula in an SBML model should assume that names appearing in the formula are the identifiers of <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a>, <a class="el" href="class_parameter__t.html" title=" An SBML parameter: a named symbol with a value. ">Parameter_t</a>, <a class="el" href="class_compartment__t.html" title=" An SBML compartment, where species are located. ">Compartment_t</a>, <a class="el" href="class_function_definition__t.html" title=" A user-defined function in an SBML model. ">FunctionDefinition_t</a>, <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a> (in SBML Levels&#160;2 and&#160;3), or <a class="el" href="class_species_reference__t.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference_t</a> (in SBML Level&#160;3 only) objects defined in a model. When a function call is involved, the syntax consists of a function identifier, followed by optional white space, followed by an opening parenthesis, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis. There is an almost one-to-one mapping between the list of predefined functions available, and those defined in MathML. All of the MathML functions are recognized; this set is larger than the functions defined in SBML Level&#160;1. In the subset of functions that overlap between MathML and SBML Level&#160;1, there exist a few differences. The following table summarizes the differences between the predefined functions in SBML Level&#160;1 and the MathML equivalents in SBML Levels&#160;2 and &#160;3:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Text string formula functions</th>
     <th align="left">MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(x)</code> or <code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(x)</code> or <code>root(2, x)</code></td></tr>
<caption class="top-caption">Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>

<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a></dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#_a11">createExampleSBML.c</a>, <a class="el" href="print_math_8c-example.html#_a1">printMath.c</a>, <a class="el" href="translate_l3_math_8c-example.html#_a13">translateL3Math.c</a>, and <a class="el" href="translate_math_8c-example.html#_a0">translateMath.c</a>.</dd>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6325eec724b979c5c181dc948baa76a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8">ASTNode_addChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *disownedChild)</td></tr>
<tr class="memdesc:a6325eec724b979c5c181dc948baa76a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node as a child of another node.  <a href="#a6325eec724b979c5c181dc948baa76a8">More...</a><br /></td></tr>
<tr class="separator:a6325eec724b979c5c181dc948baa76a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58809a0e4fc64a5663ab64c59408092"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac58809a0e4fc64a5663ab64c59408092">ASTNode_addSemanticsAnnotation</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_x_m_l_node__t.html">XMLNode_t</a> *disownedAnnotation)</td></tr>
<tr class="memdesc:ac58809a0e4fc64a5663ab64c59408092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a given XML node structure as a MathML <em>semantic annotation</em> of a given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.  <a href="#ac58809a0e4fc64a5663ab64c59408092">More...</a><br /></td></tr>
<tr class="separator:ac58809a0e4fc64a5663ab64c59408092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec78a0f356a913c3bb2ec38c022ba52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a7ec78a0f356a913c3bb2ec38c022ba52">ASTNode_canonicalize</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a7ec78a0f356a913c3bb2ec38c022ba52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given node to a canonical form and returns <code>1</code> if successful, <code>0</code> otherwise.  <a href="#a7ec78a0f356a913c3bb2ec38c022ba52">More...</a><br /></td></tr>
<tr class="separator:a7ec78a0f356a913c3bb2ec38c022ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb89a516f23169d80f003f292c621c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a0cb89a516f23169d80f003f292c621c0">ASTNode_create</a> (void)</td></tr>
<tr class="memdesc:a0cb89a516f23169d80f003f292c621c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure and returns a pointer to it.  <a href="#a0cb89a516f23169d80f003f292c621c0">More...</a><br /></td></tr>
<tr class="separator:a0cb89a516f23169d80f003f292c621c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73896396367d5ed526b93a054f15c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ab73896396367d5ed526b93a054f15c76">ASTNode_createFromToken</a> (<a class="el" href="group__core.html#struct_token__t">Token_t</a> *token)</td></tr>
<tr class="memdesc:ab73896396367d5ed526b93a054f15c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure from the given <a class="el" href="group__core.html#struct_token__t" title=" Structure used to store a token returned by FormulaTokenizer_nextToken(). ">Token_t</a> data and returns a pointer to it.  <a href="#ab73896396367d5ed526b93a054f15c76">More...</a><br /></td></tr>
<tr class="separator:ab73896396367d5ed526b93a054f15c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fa2b9d7071397d474bc1477946c4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a96fa2b9d7071397d474bc1477946c4c0">ASTNode_createWithType</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type)</td></tr>
<tr class="memdesc:a96fa2b9d7071397d474bc1477946c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure and sets its type.  <a href="#a96fa2b9d7071397d474bc1477946c4c0">More...</a><br /></td></tr>
<tr class="separator:a96fa2b9d7071397d474bc1477946c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc62036260048545d6ef8a5189d828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac3dc62036260048545d6ef8a5189d828">ASTNode_deepCopy</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ac3dc62036260048545d6ef8a5189d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a recursive copy of a node and all its children.  <a href="#ac3dc62036260048545d6ef8a5189d828">More...</a><br /></td></tr>
<tr class="separator:ac3dc62036260048545d6ef8a5189d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7f54741734d9d302736a8cb6b31c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a9fa7f54741734d9d302736a8cb6b31c3">ASTNode_fillListOfNodes</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a> predicate, <a class="el" href="class_list__t.html">List_t</a> *lst)</td></tr>
<tr class="memdesc:a9fa7f54741734d9d302736a8cb6b31c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of nodes rooted at a given node and satisfying a given predicate.  <a href="#a9fa7f54741734d9d302736a8cb6b31c3">More...</a><br /></td></tr>
<tr class="separator:a9fa7f54741734d9d302736a8cb6b31c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5616119e95fab54fe876ac79e595a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af5616119e95fab54fe876ac79e595a27">ASTNode_free</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:af5616119e95fab54fe876ac79e595a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure, including any child nodes.  <a href="#af5616119e95fab54fe876ac79e595a27">More...</a><br /></td></tr>
<tr class="separator:af5616119e95fab54fe876ac79e595a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab75b1ed83aa9592e960c8dd3f1717f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a2ab75b1ed83aa9592e960c8dd3f1717f">ASTNode_freeName</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a2ab75b1ed83aa9592e960c8dd3f1717f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the name field of a given node and sets it to null.  <a href="#a2ab75b1ed83aa9592e960c8dd3f1717f">More...</a><br /></td></tr>
<tr class="separator:a2ab75b1ed83aa9592e960c8dd3f1717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93cb10db380ba823ad311d9ddc4008"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aca93cb10db380ba823ad311d9ddc4008">ASTNode_getCharacter</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:aca93cb10db380ba823ad311d9ddc4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a node as a single character.  <a href="#aca93cb10db380ba823ad311d9ddc4008">More...</a><br /></td></tr>
<tr class="separator:aca93cb10db380ba823ad311d9ddc4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9e764c716ddcfb521ecd254b8305a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#abc9e764c716ddcfb521ecd254b8305a5">ASTNode_getChild</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n)</td></tr>
<tr class="memdesc:abc9e764c716ddcfb521ecd254b8305a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child of a node according to its index number.  <a href="#abc9e764c716ddcfb521ecd254b8305a5">More...</a><br /></td></tr>
<tr class="separator:abc9e764c716ddcfb521ecd254b8305a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea637fa1cb259b3a30d23c07ea229f4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6ea637fa1cb259b3a30d23c07ea229f4">ASTNode_getClass</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6ea637fa1cb259b3a30d23c07ea229f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML "class" attribute of a given node.  <a href="#a6ea637fa1cb259b3a30d23c07ea229f4">More...</a><br /></td></tr>
<tr class="separator:a6ea637fa1cb259b3a30d23c07ea229f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c9bcb0d60d4e5c7362266be262cb17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes__t.html">XMLAttributes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ae1c9bcb0d60d4e5c7362266be262cb17">ASTNode_getDefinitionURL</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ae1c9bcb0d60d4e5c7362266be262cb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML "definitionURL" attribute value of the given node.  <a href="#ae1c9bcb0d60d4e5c7362266be262cb17">More...</a><br /></td></tr>
<tr class="separator:ae1c9bcb0d60d4e5c7362266be262cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7903fd28aa8694ff78932453bee7da"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6a7903fd28aa8694ff78932453bee7da">ASTNode_getDefinitionURLString</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6a7903fd28aa8694ff78932453bee7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML "definitionURL" attribute value of the given node as a string.  <a href="#a6a7903fd28aa8694ff78932453bee7da">More...</a><br /></td></tr>
<tr class="separator:a6a7903fd28aa8694ff78932453bee7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2a8188004b6e23398d7df0f98c0307"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#acc2a8188004b6e23398d7df0f98c0307">ASTNode_getDenominator</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:acc2a8188004b6e23398d7df0f98c0307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the numerator value of a node representing a rational number.  <a href="#acc2a8188004b6e23398d7df0f98c0307">More...</a><br /></td></tr>
<tr class="separator:acc2a8188004b6e23398d7df0f98c0307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc84f170161d8bce106906dc0aab0d2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#afcc84f170161d8bce106906dc0aab0d2">ASTNode_getExponent</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:afcc84f170161d8bce106906dc0aab0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exponent value of a node.  <a href="#afcc84f170161d8bce106906dc0aab0d2">More...</a><br /></td></tr>
<tr class="separator:afcc84f170161d8bce106906dc0aab0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b6741584e916fdadd48d2eef47e281"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a22b6741584e916fdadd48d2eef47e281">ASTNode_getId</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a22b6741584e916fdadd48d2eef47e281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML "id" attribute of a given node.  <a href="#a22b6741584e916fdadd48d2eef47e281">More...</a><br /></td></tr>
<tr class="separator:a22b6741584e916fdadd48d2eef47e281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f09ac9eae29bf5a17e6783f422b7ce"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a16f09ac9eae29bf5a17e6783f422b7ce">ASTNode_getInteger</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a16f09ac9eae29bf5a17e6783f422b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a node as an integer.  <a href="#a16f09ac9eae29bf5a17e6783f422b7ce">More...</a><br /></td></tr>
<tr class="separator:a16f09ac9eae29bf5a17e6783f422b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac334fd6b6dafa3e5f9dce91cd96d846e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac334fd6b6dafa3e5f9dce91cd96d846e">ASTNode_getLeftChild</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ac334fd6b6dafa3e5f9dce91cd96d846e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left-most child of a given node.  <a href="#ac334fd6b6dafa3e5f9dce91cd96d846e">More...</a><br /></td></tr>
<tr class="separator:ac334fd6b6dafa3e5f9dce91cd96d846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091679cdf3bfecb68e04e76e326f751b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list__t.html">List_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a091679cdf3bfecb68e04e76e326f751b">ASTNode_getListOfNodes</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a> predicate)</td></tr>
<tr class="memdesc:a091679cdf3bfecb68e04e76e326f751b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of nodes rooted at a given node and satisfying a given predicate.  <a href="#a091679cdf3bfecb68e04e76e326f751b">More...</a><br /></td></tr>
<tr class="separator:a091679cdf3bfecb68e04e76e326f751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af591e133c6243681cc58888de8db0b53"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af591e133c6243681cc58888de8db0b53">ASTNode_getMantissa</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:af591e133c6243681cc58888de8db0b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mantissa value of a node.  <a href="#af591e133c6243681cc58888de8db0b53">More...</a><br /></td></tr>
<tr class="separator:af591e133c6243681cc58888de8db0b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1199b7a27ed532f37f0f766bbdcd980"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ab1199b7a27ed532f37f0f766bbdcd980">ASTNode_getName</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ab1199b7a27ed532f37f0f766bbdcd980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a node as a string.  <a href="#ab1199b7a27ed532f37f0f766bbdcd980">More...</a><br /></td></tr>
<tr class="separator:ab1199b7a27ed532f37f0f766bbdcd980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eca4c9c5fc1a4aee224503c30392d98"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a2eca4c9c5fc1a4aee224503c30392d98">ASTNode_getNumChildren</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a2eca4c9c5fc1a4aee224503c30392d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children of a given node.  <a href="#a2eca4c9c5fc1a4aee224503c30392d98">More...</a><br /></td></tr>
<tr class="separator:a2eca4c9c5fc1a4aee224503c30392d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d2acb3cfa5cf15500adc5f1ecb2a55"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a06d2acb3cfa5cf15500adc5f1ecb2a55">ASTNode_getNumerator</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a06d2acb3cfa5cf15500adc5f1ecb2a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the numerator value of a node representing a rational number.  <a href="#a06d2acb3cfa5cf15500adc5f1ecb2a55">More...</a><br /></td></tr>
<tr class="separator:a06d2acb3cfa5cf15500adc5f1ecb2a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a516cba95b41351a5ce09020f99d82"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a50a516cba95b41351a5ce09020f99d82">ASTNode_getNumSemanticsAnnotations</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a50a516cba95b41351a5ce09020f99d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of MathML semantic annotations inside the given node.  <a href="#a50a516cba95b41351a5ce09020f99d82">More...</a><br /></td></tr>
<tr class="separator:a50a516cba95b41351a5ce09020f99d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8272e6ad57d341788869c6b0010c0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base__t.html">SBase_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ad8272e6ad57d341788869c6b0010c0e2">ASTNode_getParentSBMLObject</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ad8272e6ad57d341788869c6b0010c0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML structure containing the given node.  <a href="#ad8272e6ad57d341788869c6b0010c0e2">More...</a><br /></td></tr>
<tr class="separator:ad8272e6ad57d341788869c6b0010c0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4329bbf8cd7a2af9e25fa092e5dd4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6a4329bbf8cd7a2af9e25fa092e5dd4f">ASTNode_getPrecedence</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6a4329bbf8cd7a2af9e25fa092e5dd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the precedence of a node in the infix math syntax of SBML Level&#160;1.  <a href="#a6a4329bbf8cd7a2af9e25fa092e5dd4f">More...</a><br /></td></tr>
<tr class="separator:a6a4329bbf8cd7a2af9e25fa092e5dd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5864c32e5a275746c5c6cd1a05a8782f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a5864c32e5a275746c5c6cd1a05a8782f">ASTNode_getReal</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a5864c32e5a275746c5c6cd1a05a8782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real-numbered value of a node.  <a href="#a5864c32e5a275746c5c6cd1a05a8782f">More...</a><br /></td></tr>
<tr class="separator:a5864c32e5a275746c5c6cd1a05a8782f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61aa2cefafd840423f93715231007668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a61aa2cefafd840423f93715231007668">ASTNode_getRightChild</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a61aa2cefafd840423f93715231007668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right-most child of a given node.  <a href="#a61aa2cefafd840423f93715231007668">More...</a><br /></td></tr>
<tr class="separator:a61aa2cefafd840423f93715231007668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a264af5522e4b2449f89f86d342d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node__t.html">XMLNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af95a264af5522e4b2449f89f86d342d0">ASTNode_getSemanticsAnnotation</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n)</td></tr>
<tr class="memdesc:af95a264af5522e4b2449f89f86d342d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth MathML semantic annotation attached to the given node.  <a href="#af95a264af5522e4b2449f89f86d342d0">More...</a><br /></td></tr>
<tr class="separator:af95a264af5522e4b2449f89f86d342d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d069697b1f126d9773d17e9bba45c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a70d069697b1f126d9773d17e9bba45c3">ASTNode_getStyle</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a70d069697b1f126d9773d17e9bba45c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML "style" attribute of a given node.  <a href="#a70d069697b1f126d9773d17e9bba45c3">More...</a><br /></td></tr>
<tr class="separator:a70d069697b1f126d9773d17e9bba45c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6cd351567a177ab88b961890f18c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c">ASTNode_getType</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:aad6cd351567a177ab88b961890f18c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the given node.  <a href="#aad6cd351567a177ab88b961890f18c7c">More...</a><br /></td></tr>
<tr class="separator:aad6cd351567a177ab88b961890f18c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ab5e06e28d25076d2c09674f538861"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a58ab5e06e28d25076d2c09674f538861">ASTNode_getUnits</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a58ab5e06e28d25076d2c09674f538861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML "units" attribute of a given node.  <a href="#a58ab5e06e28d25076d2c09674f538861">More...</a><br /></td></tr>
<tr class="separator:a58ab5e06e28d25076d2c09674f538861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463cba3c511f0836df7b4e7e15e474eb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a463cba3c511f0836df7b4e7e15e474eb">ASTNode_getUserData</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a463cba3c511f0836df7b4e7e15e474eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user data associated with this node.  <a href="#a463cba3c511f0836df7b4e7e15e474eb">More...</a><br /></td></tr>
<tr class="separator:a463cba3c511f0836df7b4e7e15e474eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42db011a3bf7aacb62d13fe0f9d1b2c4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a42db011a3bf7aacb62d13fe0f9d1b2c4">ASTNode_getValue</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a42db011a3bf7aacb62d13fe0f9d1b2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical value of this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>.  <a href="#a42db011a3bf7aacb62d13fe0f9d1b2c4">More...</a><br /></td></tr>
<tr class="separator:a42db011a3bf7aacb62d13fe0f9d1b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3e3926d142fad871af6a9ae8e4009"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a62a3e3926d142fad871af6a9ae8e4009">ASTNode_hasCorrectNumberArguments</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a62a3e3926d142fad871af6a9ae8e4009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node has the correct number of children for its type.  <a href="#a62a3e3926d142fad871af6a9ae8e4009">More...</a><br /></td></tr>
<tr class="separator:a62a3e3926d142fad871af6a9ae8e4009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef78fafa2b08f693bf681aaab77302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aa5ef78fafa2b08f693bf681aaab77302">ASTNode_hasTypeAndNumChildren</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type, unsigned int numchildren)</td></tr>
<tr class="memdesc:aa5ef78fafa2b08f693bf681aaab77302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is of a specific type and has a specific number of children.  <a href="#aa5ef78fafa2b08f693bf681aaab77302">More...</a><br /></td></tr>
<tr class="separator:aa5ef78fafa2b08f693bf681aaab77302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab42b3d9d1da048db4f9fa7e8f8789fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aab42b3d9d1da048db4f9fa7e8f8789fa">ASTNode_hasUnits</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:aab42b3d9d1da048db4f9fa7e8f8789fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node or any of its children have the SBML "units" attribute set.  <a href="#aab42b3d9d1da048db4f9fa7e8f8789fa">More...</a><br /></td></tr>
<tr class="separator:aab42b3d9d1da048db4f9fa7e8f8789fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364665c627b2d76e8d7bad21bd6778a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1">ASTNode_insertChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *disownedChild)</td></tr>
<tr class="memdesc:a364665c627b2d76e8d7bad21bd6778a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node at a given point in the list of children of a node.  <a href="#a364665c627b2d76e8d7bad21bd6778a1">More...</a><br /></td></tr>
<tr class="separator:a364665c627b2d76e8d7bad21bd6778a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b19607769e3366ae509810b9d0dc78f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a3b19607769e3366ae509810b9d0dc78f">ASTNode_isAvogadro</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a3b19607769e3366ae509810b9d0dc78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents the special symbol <code>avogadro</code>.  <a href="#a3b19607769e3366ae509810b9d0dc78f">More...</a><br /></td></tr>
<tr class="separator:a3b19607769e3366ae509810b9d0dc78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674a4db8d06d9b097f401e4416921682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a674a4db8d06d9b097f401e4416921682">ASTNode_isBoolean</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a674a4db8d06d9b097f401e4416921682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is some type of Boolean value or operator.  <a href="#a674a4db8d06d9b097f401e4416921682">More...</a><br /></td></tr>
<tr class="separator:a674a4db8d06d9b097f401e4416921682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41693ed536a3f8ed0cf8ced72648e3a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a41693ed536a3f8ed0cf8ced72648e3a7">ASTNode_isConstant</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a41693ed536a3f8ed0cf8ced72648e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a MathML constant.  <a href="#a41693ed536a3f8ed0cf8ced72648e3a7">More...</a><br /></td></tr>
<tr class="separator:a41693ed536a3f8ed0cf8ced72648e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ffa52569effd80dc4c8f05b10cceae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a27ffa52569effd80dc4c8f05b10cceae">ASTNode_isConstantNumber</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a27ffa52569effd80dc4c8f05b10cceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a MathML constant.  <a href="#a27ffa52569effd80dc4c8f05b10cceae">More...</a><br /></td></tr>
<tr class="separator:a27ffa52569effd80dc4c8f05b10cceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a75a5d3a61ee280376764fab101b55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aa1a75a5d3a61ee280376764fab101b55">ASTNode_isFunction</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:aa1a75a5d3a61ee280376764fab101b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a function.  <a href="#aa1a75a5d3a61ee280376764fab101b55">More...</a><br /></td></tr>
<tr class="separator:aa1a75a5d3a61ee280376764fab101b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbff513dc3ed651f3dd4b6b15542ce5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#affbff513dc3ed651f3dd4b6b15542ce5">ASTNode_isInfinity</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:affbff513dc3ed651f3dd4b6b15542ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node stands for infinity.  <a href="#affbff513dc3ed651f3dd4b6b15542ce5">More...</a><br /></td></tr>
<tr class="separator:affbff513dc3ed651f3dd4b6b15542ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6f0edbf9724b3192227bd8449103c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a01d6f0edbf9724b3192227bd8449103c">ASTNode_isInteger</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a01d6f0edbf9724b3192227bd8449103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node contains an integer value.  <a href="#a01d6f0edbf9724b3192227bd8449103c">More...</a><br /></td></tr>
<tr class="separator:a01d6f0edbf9724b3192227bd8449103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33453c3da65b164abcd98e9167297ddc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a33453c3da65b164abcd98e9167297ddc">ASTNode_isLambda</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a33453c3da65b164abcd98e9167297ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is a MathML lambda function.  <a href="#a33453c3da65b164abcd98e9167297ddc">More...</a><br /></td></tr>
<tr class="separator:a33453c3da65b164abcd98e9167297ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f024e470c75d099b1ecb8b368d6af5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6f024e470c75d099b1ecb8b368d6af5e">ASTNode_isLog10</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6f024e470c75d099b1ecb8b368d6af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents the log base-10 function.  <a href="#a6f024e470c75d099b1ecb8b368d6af5e">More...</a><br /></td></tr>
<tr class="separator:a6f024e470c75d099b1ecb8b368d6af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023b6d785bf900a974168d2ea14fa9dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a023b6d785bf900a974168d2ea14fa9dc">ASTNode_isLogical</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a023b6d785bf900a974168d2ea14fa9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is a logical operator.  <a href="#a023b6d785bf900a974168d2ea14fa9dc">More...</a><br /></td></tr>
<tr class="separator:a023b6d785bf900a974168d2ea14fa9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d6437704c3b688cbf71a0f10928a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6c3d6437704c3b688cbf71a0f10928a1">ASTNode_isName</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6c3d6437704c3b688cbf71a0f10928a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is a named entity.  <a href="#a6c3d6437704c3b688cbf71a0f10928a1">More...</a><br /></td></tr>
<tr class="separator:a6c3d6437704c3b688cbf71a0f10928a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb58317547d8879e92a03977c7cf675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#affb58317547d8879e92a03977c7cf675">ASTNode_isNaN</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:affb58317547d8879e92a03977c7cf675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents not-a-number.  <a href="#affb58317547d8879e92a03977c7cf675">More...</a><br /></td></tr>
<tr class="separator:affb58317547d8879e92a03977c7cf675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af4f898abcbf4dbcd9edc066abe0f27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a8af4f898abcbf4dbcd9edc066abe0f27">ASTNode_isNegInfinity</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a8af4f898abcbf4dbcd9edc066abe0f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents negative infinity.  <a href="#a8af4f898abcbf4dbcd9edc066abe0f27">More...</a><br /></td></tr>
<tr class="separator:a8af4f898abcbf4dbcd9edc066abe0f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6287e8d5bc16ce683e6dab33b6f604"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#afe6287e8d5bc16ce683e6dab33b6f604">ASTNode_isNumber</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:afe6287e8d5bc16ce683e6dab33b6f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node contains a number.  <a href="#afe6287e8d5bc16ce683e6dab33b6f604">More...</a><br /></td></tr>
<tr class="separator:afe6287e8d5bc16ce683e6dab33b6f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbe2535bec518e1f7824a485f0ca078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#acdbe2535bec518e1f7824a485f0ca078">ASTNode_isOperator</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:acdbe2535bec518e1f7824a485f0ca078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is a mathematical operator.  <a href="#acdbe2535bec518e1f7824a485f0ca078">More...</a><br /></td></tr>
<tr class="separator:acdbe2535bec518e1f7824a485f0ca078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7bdc5097da065ece0a84941796dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a0af7bdc5097da065ece0a84941796dd3">ASTNode_isPiecewise</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a0af7bdc5097da065ece0a84941796dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents the MathML <code>&lt;piecewise&gt;</code> operator.  <a href="#a0af7bdc5097da065ece0a84941796dd3">More...</a><br /></td></tr>
<tr class="separator:a0af7bdc5097da065ece0a84941796dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6937df6eea839c0bfc5c58b672448f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac6937df6eea839c0bfc5c58b672448f9">ASTNode_isRational</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ac6937df6eea839c0bfc5c58b672448f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a rational number.  <a href="#ac6937df6eea839c0bfc5c58b672448f9">More...</a><br /></td></tr>
<tr class="separator:ac6937df6eea839c0bfc5c58b672448f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427afbdd9272f8b410b46ed04b9c2e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af427afbdd9272f8b410b46ed04b9c2e1">ASTNode_isReal</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:af427afbdd9272f8b410b46ed04b9c2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a real number.  <a href="#af427afbdd9272f8b410b46ed04b9c2e1">More...</a><br /></td></tr>
<tr class="separator:af427afbdd9272f8b410b46ed04b9c2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd44dcefb47d8f289fee176c8cbb8f9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#abd44dcefb47d8f289fee176c8cbb8f9a">ASTNode_isRelational</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:abd44dcefb47d8f289fee176c8cbb8f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a MathML relational operator.  <a href="#abd44dcefb47d8f289fee176c8cbb8f9a">More...</a><br /></td></tr>
<tr class="separator:abd44dcefb47d8f289fee176c8cbb8f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d268b1f14bac28726f29148cfe104a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a2d268b1f14bac28726f29148cfe104a2">ASTNode_isSetClass</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a2d268b1f14bac28726f29148cfe104a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node's MathML "class" attribute is set.  <a href="#a2d268b1f14bac28726f29148cfe104a2">More...</a><br /></td></tr>
<tr class="separator:a2d268b1f14bac28726f29148cfe104a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c11df4c38a28db8f3fc8107c5efdc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a50c11df4c38a28db8f3fc8107c5efdc4">ASTNode_isSetId</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a50c11df4c38a28db8f3fc8107c5efdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node's MathML "id" attribute is set.  <a href="#a50c11df4c38a28db8f3fc8107c5efdc4">More...</a><br /></td></tr>
<tr class="separator:a50c11df4c38a28db8f3fc8107c5efdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb45cff1b064de4ad3d73556a64b2fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6fb45cff1b064de4ad3d73556a64b2fd">ASTNode_isSetParentSBMLObject</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6fb45cff1b064de4ad3d73556a64b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node's parent SBML object is set.  <a href="#a6fb45cff1b064de4ad3d73556a64b2fd">More...</a><br /></td></tr>
<tr class="separator:a6fb45cff1b064de4ad3d73556a64b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d72e8d3de6ba6ae9dabf6dd3520c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a73d72e8d3de6ba6ae9dabf6dd3520c54">ASTNode_isSetStyle</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a73d72e8d3de6ba6ae9dabf6dd3520c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node's MathML "style" attribute is set.  <a href="#a73d72e8d3de6ba6ae9dabf6dd3520c54">More...</a><br /></td></tr>
<tr class="separator:a73d72e8d3de6ba6ae9dabf6dd3520c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6968a1543fd93af358ff83406f300d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ab6968a1543fd93af358ff83406f300d3">ASTNode_isSetUnits</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ab6968a1543fd93af358ff83406f300d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node's SBML "units" attribute is set.  <a href="#ab6968a1543fd93af358ff83406f300d3">More...</a><br /></td></tr>
<tr class="separator:ab6968a1543fd93af358ff83406f300d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea40c2df7746f001929b47c627a8a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#acea40c2df7746f001929b47c627a8a31">ASTNode_isSetUserData</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:acea40c2df7746f001929b47c627a8a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node's user data object is set.  <a href="#acea40c2df7746f001929b47c627a8a31">More...</a><br /></td></tr>
<tr class="separator:acea40c2df7746f001929b47c627a8a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a064aa38d489440911cdeb49d0bba38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6a064aa38d489440911cdeb49d0bba38">ASTNode_isSqrt</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a6a064aa38d489440911cdeb49d0bba38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is the MathML square-root operator.  <a href="#a6a064aa38d489440911cdeb49d0bba38">More...</a><br /></td></tr>
<tr class="separator:a6a064aa38d489440911cdeb49d0bba38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac050df5b95a4bc6d8d4c525321ac3116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac050df5b95a4bc6d8d4c525321ac3116">ASTNode_isUMinus</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:ac050df5b95a4bc6d8d4c525321ac3116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node represents a unary minus.  <a href="#ac050df5b95a4bc6d8d4c525321ac3116">More...</a><br /></td></tr>
<tr class="separator:ac050df5b95a4bc6d8d4c525321ac3116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51d09179e715254bc2c5b1526d8c91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a7d51d09179e715254bc2c5b1526d8c91">ASTNode_isUnknown</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a7d51d09179e715254bc2c5b1526d8c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type of the node is unknown.  <a href="#a7d51d09179e715254bc2c5b1526d8c91">More...</a><br /></td></tr>
<tr class="separator:a7d51d09179e715254bc2c5b1526d8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e10ad3a7a5e9412a4034e5de0becc09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a5e10ad3a7a5e9412a4034e5de0becc09">ASTNode_isUPlus</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a5e10ad3a7a5e9412a4034e5de0becc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is a unary plus.  <a href="#a5e10ad3a7a5e9412a4034e5de0becc09">More...</a><br /></td></tr>
<tr class="separator:a5e10ad3a7a5e9412a4034e5de0becc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8007ec76f0f38d289446ada912dbb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6">ASTNode_isWellFormedASTNode</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:aee8007ec76f0f38d289446ada912dbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is well-formed.  <a href="#aee8007ec76f0f38d289446ada912dbb6">More...</a><br /></td></tr>
<tr class="separator:aee8007ec76f0f38d289446ada912dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ee0ff04953bf084bd159e1cbda69f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0">ASTNode_prependChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *disownedChild)</td></tr>
<tr class="memdesc:ae2ee0ff04953bf084bd159e1cbda69f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node as a child of another node.  <a href="#ae2ee0ff04953bf084bd159e1cbda69f0">More...</a><br /></td></tr>
<tr class="separator:ae2ee0ff04953bf084bd159e1cbda69f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968f1b2488e4e6f3d49c1567fefbeedc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a968f1b2488e4e6f3d49c1567fefbeedc">ASTNode_reduceToBinary</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a968f1b2488e4e6f3d49c1567fefbeedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the given node to a binary true.  <a href="#a968f1b2488e4e6f3d49c1567fefbeedc">More...</a><br /></td></tr>
<tr class="separator:a968f1b2488e4e6f3d49c1567fefbeedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a7c454ed9dbe23fc9a2385aee29756"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756">ASTNode_removeChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n)</td></tr>
<tr class="memdesc:a73a7c454ed9dbe23fc9a2385aee29756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth child of a given node.  <a href="#a73a7c454ed9dbe23fc9a2385aee29756">More...</a><br /></td></tr>
<tr class="separator:a73a7c454ed9dbe23fc9a2385aee29756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802619e15437b7fdc85c4da9ef6c3c04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a802619e15437b7fdc85c4da9ef6c3c04">ASTNode_replaceAndDeleteChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *disownedChild)</td></tr>
<tr class="memdesc:a802619e15437b7fdc85c4da9ef6c3c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces and deletes the nth child of a given node.  <a href="#a802619e15437b7fdc85c4da9ef6c3c04">More...</a><br /></td></tr>
<tr class="separator:a802619e15437b7fdc85c4da9ef6c3c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf806f71c75d7af5df9c83a3ded9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a22cf806f71c75d7af5df9c83a3ded9dc">ASTNode_replaceArgument</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *bvar, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *arg)</td></tr>
<tr class="memdesc:a22cf806f71c75d7af5df9c83a3ded9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of a given name with a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.  <a href="#a22cf806f71c75d7af5df9c83a3ded9dc">More...</a><br /></td></tr>
<tr class="separator:a22cf806f71c75d7af5df9c83a3ded9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c1c97f78efe675e96ae34b11b4dae9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9">ASTNode_replaceChild</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, unsigned int n, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *disownedChild)</td></tr>
<tr class="memdesc:aa7c1c97f78efe675e96ae34b11b4dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the nth child of a given node.  <a href="#aa7c1c97f78efe675e96ae34b11b4dae9">More...</a><br /></td></tr>
<tr class="separator:aa7c1c97f78efe675e96ae34b11b4dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b0073a3b87eb4eb6371fa62dd047b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af0b0073a3b87eb4eb6371fa62dd047b5">ASTNode_returnsBoolean</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:af0b0073a3b87eb4eb6371fa62dd047b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is something that returns a Boolean value.  <a href="#af0b0073a3b87eb4eb6371fa62dd047b5">More...</a><br /></td></tr>
<tr class="separator:af0b0073a3b87eb4eb6371fa62dd047b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c005348494077d1963e8475131797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a268c005348494077d1963e8475131797">ASTNode_returnsBooleanForModel</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const <a class="el" href="class_model__t.html">Model_t</a> *model)</td></tr>
<tr class="memdesc:a268c005348494077d1963e8475131797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is something that returns a Boolean value.  <a href="#a268c005348494077d1963e8475131797">More...</a><br /></td></tr>
<tr class="separator:a268c005348494077d1963e8475131797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5442e365c7d5e804734963429c1bcf4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a5442e365c7d5e804734963429c1bcf4f">ASTNode_setCharacter</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, char value)</td></tr>
<tr class="memdesc:a5442e365c7d5e804734963429c1bcf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given node to a character.  <a href="#a5442e365c7d5e804734963429c1bcf4f">More...</a><br /></td></tr>
<tr class="separator:a5442e365c7d5e804734963429c1bcf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9233c21f7c65a409e7bc1c63121e6ac3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a9233c21f7c65a409e7bc1c63121e6ac3">ASTNode_setClass</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *className)</td></tr>
<tr class="memdesc:a9233c21f7c65a409e7bc1c63121e6ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML "class" of the given node.  <a href="#a9233c21f7c65a409e7bc1c63121e6ac3">More...</a><br /></td></tr>
<tr class="separator:a9233c21f7c65a409e7bc1c63121e6ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e652d935fa0e613bb2c77e5fb74bd59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a9e652d935fa0e613bb2c77e5fb74bd59">ASTNode_setDefinitionURL</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_x_m_l_attributes__t.html">XMLAttributes_t</a> *defnURL)</td></tr>
<tr class="memdesc:a9e652d935fa0e613bb2c77e5fb74bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML "definitionURL" attribute of the given node.  <a href="#a9e652d935fa0e613bb2c77e5fb74bd59">More...</a><br /></td></tr>
<tr class="separator:a9e652d935fa0e613bb2c77e5fb74bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03905b1eb04d9770aa0fb9342405f44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ae03905b1eb04d9770aa0fb9342405f44">ASTNode_setDefinitionURLString</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *defnURL)</td></tr>
<tr class="memdesc:ae03905b1eb04d9770aa0fb9342405f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML "definitionURL" attribute of the given node.  <a href="#ae03905b1eb04d9770aa0fb9342405f44">More...</a><br /></td></tr>
<tr class="separator:ae03905b1eb04d9770aa0fb9342405f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed906c880e0fdd89491cdbc2f3d979ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aed906c880e0fdd89491cdbc2f3d979ea">ASTNode_setId</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *id)</td></tr>
<tr class="memdesc:aed906c880e0fdd89491cdbc2f3d979ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML "id" attribute of the given node.  <a href="#aed906c880e0fdd89491cdbc2f3d979ea">More...</a><br /></td></tr>
<tr class="separator:aed906c880e0fdd89491cdbc2f3d979ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394a038735e0acea492477553e2b4785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a394a038735e0acea492477553e2b4785">ASTNode_setInteger</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, long value)</td></tr>
<tr class="memdesc:a394a038735e0acea492477553e2b4785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given node to a integer and sets it type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>.  <a href="#a394a038735e0acea492477553e2b4785">More...</a><br /></td></tr>
<tr class="separator:a394a038735e0acea492477553e2b4785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae71126053a0e83f8c11d7f7e0b68a62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aae71126053a0e83f8c11d7f7e0b68a62">ASTNode_setName</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *name)</td></tr>
<tr class="memdesc:aae71126053a0e83f8c11d7f7e0b68a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node to represent a named entity.  <a href="#aae71126053a0e83f8c11d7f7e0b68a62">More...</a><br /></td></tr>
<tr class="separator:aae71126053a0e83f8c11d7f7e0b68a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f9ccf735798998550dee4edfe1dcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ad37f9ccf735798998550dee4edfe1dcd">ASTNode_setRational</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, long numerator, long denominator)</td></tr>
<tr class="memdesc:ad37f9ccf735798998550dee4edfe1dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given node to a rational number and sets its type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>.  <a href="#ad37f9ccf735798998550dee4edfe1dcd">More...</a><br /></td></tr>
<tr class="separator:ad37f9ccf735798998550dee4edfe1dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6122c93db7afa2f28ba62e1eac46efba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6122c93db7afa2f28ba62e1eac46efba">ASTNode_setReal</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, double value)</td></tr>
<tr class="memdesc:a6122c93db7afa2f28ba62e1eac46efba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given node to a real (<code>double</code>) and sets its type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>.  <a href="#a6122c93db7afa2f28ba62e1eac46efba">More...</a><br /></td></tr>
<tr class="separator:a6122c93db7afa2f28ba62e1eac46efba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ddacc52b27b5466bb6c8b0c526984f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a23ddacc52b27b5466bb6c8b0c526984f">ASTNode_setRealWithExponent</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, double mantissa, long exponent)</td></tr>
<tr class="memdesc:a23ddacc52b27b5466bb6c8b0c526984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given node to a real (<code>double</code>) in two parts, a mantissa and an exponent.  <a href="#a23ddacc52b27b5466bb6c8b0c526984f">More...</a><br /></td></tr>
<tr class="separator:a23ddacc52b27b5466bb6c8b0c526984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc9d1999c4e90503a10315cb26fda7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a1adc9d1999c4e90503a10315cb26fda7">ASTNode_setStyle</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *style)</td></tr>
<tr class="memdesc:a1adc9d1999c4e90503a10315cb26fda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML "style" of the given node.  <a href="#a1adc9d1999c4e90503a10315cb26fda7">More...</a><br /></td></tr>
<tr class="separator:a1adc9d1999c4e90503a10315cb26fda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4732ce088dd7bb4fa0542d40fdc72b84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a4732ce088dd7bb4fa0542d40fdc72b84">ASTNode_setType</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type)</td></tr>
<tr class="memdesc:a4732ce088dd7bb4fa0542d40fdc72b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly sets the type of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.  <a href="#a4732ce088dd7bb4fa0542d40fdc72b84">More...</a><br /></td></tr>
<tr class="separator:a4732ce088dd7bb4fa0542d40fdc72b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ba54073600b30a5e248ca6b288db2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ae2ba54073600b30a5e248ca6b288db2a">ASTNode_setUnits</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, const char *units)</td></tr>
<tr class="memdesc:ae2ba54073600b30a5e248ca6b288db2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the units of the given node.  <a href="#ae2ba54073600b30a5e248ca6b288db2a">More...</a><br /></td></tr>
<tr class="separator:ae2ba54073600b30a5e248ca6b288db2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c4b2b0ef0fb780f3214ad1bd4a892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aea8c4b2b0ef0fb780f3214ad1bd4a892">ASTNode_setUserData</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, void *userData)</td></tr>
<tr class="memdesc:aea8c4b2b0ef0fb780f3214ad1bd4a892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user data of the given node.  <a href="#aea8c4b2b0ef0fb780f3214ad1bd4a892">More...</a><br /></td></tr>
<tr class="separator:aea8c4b2b0ef0fb780f3214ad1bd4a892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e710c2223c9488bbb751c69d07ee689"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a4e710c2223c9488bbb751c69d07ee689">ASTNode_swapChildren</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *that)</td></tr>
<tr class="memdesc:a4e710c2223c9488bbb751c69d07ee689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the children of two nodes.  <a href="#a4e710c2223c9488bbb751c69d07ee689">More...</a><br /></td></tr>
<tr class="separator:a4e710c2223c9488bbb751c69d07ee689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb034919598e8d3bf7e2a1cd21a6c31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a3fb034919598e8d3bf7e2a1cd21a6c31">ASTNode_unsetClass</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a3fb034919598e8d3bf7e2a1cd21a6c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML "class" attribute of the given node.  <a href="#a3fb034919598e8d3bf7e2a1cd21a6c31">More...</a><br /></td></tr>
<tr class="separator:a3fb034919598e8d3bf7e2a1cd21a6c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aa72a2d49306bbaf046197a4128b8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a38aa72a2d49306bbaf046197a4128b8b">ASTNode_unsetId</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a38aa72a2d49306bbaf046197a4128b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML "id" attribute of the given node.  <a href="#a38aa72a2d49306bbaf046197a4128b8b">More...</a><br /></td></tr>
<tr class="separator:a38aa72a2d49306bbaf046197a4128b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c441a24228ee0b7b1246dba67d5b8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a19c441a24228ee0b7b1246dba67d5b8b">ASTNode_unsetStyle</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a19c441a24228ee0b7b1246dba67d5b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML "style" attribute of the given node.  <a href="#a19c441a24228ee0b7b1246dba67d5b8b">More...</a><br /></td></tr>
<tr class="separator:a19c441a24228ee0b7b1246dba67d5b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2244b486a1a104b14639602feec5340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af2244b486a1a104b14639602feec5340">ASTNode_unsetUnits</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:af2244b486a1a104b14639602feec5340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the units associated with the given node.  <a href="#af2244b486a1a104b14639602feec5340">More...</a><br /></td></tr>
<tr class="separator:af2244b486a1a104b14639602feec5340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132dd4d210148145e8db749668ea0091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a132dd4d210148145e8db749668ea0091">ASTNode_unsetUserData</a> (<a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a132dd4d210148145e8db749668ea0091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the user data of the given node.  <a href="#a132dd4d210148145e8db749668ea0091">More...</a><br /></td></tr>
<tr class="separator:a132dd4d210148145e8db749668ea0091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f358b912b5d2479e7184d1f657d5819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a7f358b912b5d2479e7184d1f657d5819">readMathMLFromString</a> (const char *xml)</td></tr>
<tr class="memdesc:a7f358b912b5d2479e7184d1f657d5819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree, and returns a pointer to the root of the tree.  <a href="#a7f358b912b5d2479e7184d1f657d5819">More...</a><br /></td></tr>
<tr class="separator:a7f358b912b5d2479e7184d1f657d5819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e588cb2afd2cabd317ea70f10b3c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a52e588cb2afd2cabd317ea70f10b3c97">readMathMLFromStringWithNamespaces</a> (const char *xml, <a class="el" href="class_x_m_l_namespaces__t.html">XMLNamespaces_t</a> *xmlns)</td></tr>
<tr class="memdesc:a52e588cb2afd2cabd317ea70f10b3c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree, and returns a pointer to the root of the tree.  <a href="#a52e588cb2afd2cabd317ea70f10b3c97">More...</a><br /></td></tr>
<tr class="separator:a52e588cb2afd2cabd317ea70f10b3c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac029dddfabae36ca83d8091739cd88"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88">SBML_formulaToL3String</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *tree)</td></tr>
<tr class="memdesc:afac029dddfabae36ca83d8091739cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1, but extended to include elements from SBML Level&#160;2 and SBML Level&#160;3.  <a href="#afac029dddfabae36ca83d8091739cd88">More...</a><br /></td></tr>
<tr class="separator:afac029dddfabae36ca83d8091739cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e387dfc8abffaebec3d57625f55d3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3">SBML_formulaToL3StringWithSettings</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *tree, const <a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> *settings)</td></tr>
<tr class="memdesc:aa38e387dfc8abffaebec3d57625f55d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an AST to a string representation of a formula using a syntax basically derived from SBML Level&#160;1, with behavior modifiable with custom settings.  <a href="#aa38e387dfc8abffaebec3d57625f55d3">More...</a><br /></td></tr>
<tr class="separator:aa38e387dfc8abffaebec3d57625f55d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6432993e301b891cea45b10ed8a0b464"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464">SBML_formulaToString</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *tree)</td></tr>
<tr class="memdesc:a6432993e301b891cea45b10ed8a0b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an AST to a string representation of a formula using a syntax basically derived from SBML Level&#160;1.  <a href="#a6432993e301b891cea45b10ed8a0b464">More...</a><br /></td></tr>
<tr class="separator:a6432993e301b891cea45b10ed8a0b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cbd4be2774c80c82b3a678ad71e951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac4cbd4be2774c80c82b3a678ad71e951">SBML_getDefaultL3ParserSettings</a> ()</td></tr>
<tr class="separator:ac4cbd4be2774c80c82b3a678ad71e951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f79bfaf0dd532cd0a57062fe9523f4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4">SBML_getLastParseL3Error</a> ()</td></tr>
<tr class="memdesc:a25f79bfaf0dd532cd0a57062fe9523f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last error reported by the "L3" mathematical formula parser.  <a href="#a25f79bfaf0dd532cd0a57062fe9523f4">More...</a><br /></td></tr>
<tr class="separator:a25f79bfaf0dd532cd0a57062fe9523f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71bc45f2f43f4c3202f7a147e370906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula</a> (const char *formula)</td></tr>
<tr class="separator:ae71bc45f2f43f4c3202f7a147e370906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb78ec9e1237db0e74230cfa5a10598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598">SBML_parseL3Formula</a> (const char *formula)</td></tr>
<tr class="memdesc:a8bb78ec9e1237db0e74230cfa5a10598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a text string as a mathematical formula and returns an AST representation of it.  <a href="#a8bb78ec9e1237db0e74230cfa5a10598">More...</a><br /></td></tr>
<tr class="separator:a8bb78ec9e1237db0e74230cfa5a10598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80016dfe4a4038c9a497ebc048132e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28">SBML_parseL3FormulaWithModel</a> (const char *formula, const <a class="el" href="class_model__t.html">Model_t</a> *model)</td></tr>
<tr class="memdesc:a80016dfe4a4038c9a497ebc048132e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a text string as a mathematical formula using a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> to resolve symbols, and returns an AST representation of the result.  <a href="#a80016dfe4a4038c9a497ebc048132e28">More...</a><br /></td></tr>
<tr class="separator:a80016dfe4a4038c9a497ebc048132e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc22ca3cfa5450713eb88a6aa824ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2">SBML_parseL3FormulaWithSettings</a> (const char *formula, const <a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> *settings)</td></tr>
<tr class="memdesc:a1cc22ca3cfa5450713eb88a6aa824ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a text string as a mathematical formula using specific parser settings and returns an AST representation of the result.  <a href="#a1cc22ca3cfa5450713eb88a6aa824ad2">More...</a><br /></td></tr>
<tr class="separator:a1cc22ca3cfa5450713eb88a6aa824ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e70c7afa39b921d879cdab7a426b6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#a988e70c7afa39b921d879cdab7a426b6">writeMathMLToString</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node)</td></tr>
<tr class="memdesc:a988e70c7afa39b921d879cdab7a426b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> (and its children) to a string as MathML, and returns the string.  <a href="#a988e70c7afa39b921d879cdab7a426b6">More...</a><br /></td></tr>
<tr class="separator:a988e70c7afa39b921d879cdab7a426b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b80199364ed95883587997eddcea3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#af42b80199364ed95883587997eddcea3">writeMathMLToString</a> (const ASTNode *node)</td></tr>
<tr class="separator:af42b80199364ed95883587997eddcea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70fefd98ddedee8b0214220018608c0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node__t.html#ac70fefd98ddedee8b0214220018608c0">writeMathMLWithNamespaceToString</a> (const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *node, <a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *sbmlns)</td></tr>
<tr class="memdesc:ac70fefd98ddedee8b0214220018608c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given AST node (and its children) to a string as MathML, and returns the string.  <a href="#ac70fefd98ddedee8b0214220018608c0">More...</a><br /></td></tr>
<tr class="separator:ac70fefd98ddedee8b0214220018608c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6325eec724b979c5c181dc948baa76a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node as a child of another node. </p>
<p>Child nodes are added in order from "left-to-right".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node which will get the new child node </td></tr>
    <tr><td class="paramname">disownedChild</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> instance to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0" title="Adds a node as a child of another node. ">ASTNode_prependChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9" title="Replaces the nth child of a given node. ">ASTNode_replaceChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1" title="Insert a new child node at a given point in the list of children of a node. ">ASTNode_insertChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756" title="Removes the nth child of a given node. ">ASTNode_removeChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a41">createExampleSBML.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac58809a0e4fc64a5663ab64c59408092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_addSemanticsAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_node__t.html">XMLNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedAnnotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a given XML node structure as a MathML <em>semantic annotation</em> of a given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">disownedAnnotation</td><td>the annotation to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although SBML permits the semantic annotation construct in MathML expressions, the truth is that this construct has so far (at this time of this writing, which is early 2011) seen very little use in SBML software. The full implications of using semantic annotations are still poorly understood. If you wish to use this construct, we urge you to discuss possible uses and applications on the SBML discussion lists, particularly <a href="http://sbml.org/Forums" target="_blank">sbml-discuss&amp;#64;caltech.edu</a> and/or <a href="http://sbml.org/Forums" target="_blank">sbml-interoperability&amp;#64;caltech.edu</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ec78a0f356a913c3bb2ec38c022ba52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a given node to a canonical form and returns <code>1</code> if successful, <code>0</code> otherwise. </p>
<p>The rules determining the canonical form conversion are as follows:</p>
<ul>
<li>If the node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> and the node name matches <code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code> the node type is converted to the corresponding <code>AST_CONSTANT_</code><em><span class="placeholder">X</span></em> type. </li>
<li>If the node type is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> and the node name matches an SBML (MathML) function name, logical operator name, or relational operator name, the node is converted to the corresponding <code>AST_FUNCTION_</code><em><span class="placeholder">X</span></em> or <code>AST_LOGICAL_</code><em><span class="placeholder">X</span></em> type.</li>
</ul>
<p>SBML Level&#160;1 function names are searched first; thus, for example, canonicalizing <code>log</code> will result in a node type of <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a86257b8c9f202d2afbb7397b7def0d8e">AST_FUNCTION_LN</a>. (See the SBML Level&#160;1 Version&#160;2 Specification, Appendix C.)</p>
<p>Sometimes, canonicalization of a node results in a structural conversion of the node as a result of adding a child. For example, a node with the SBML Level&#160;1 function name <code>sqr</code> and a single child node (the argument) will be transformed to a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b73ae9941e588add41be17a664284ab">AST_FUNCTION_POWER</a> with two children. The first child will remain unchanged, but the second child will be an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> and a value of 2. The function names that result in structural changes are: <code>log10</code>, <code>sqr</code>, and <code>sqrt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if successful, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cb89a516f23169d80f003f292c621c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure and returns a pointer to it. </p>
<p>The returned node will have a type of <code>AST_UNKNOWN</code>. The caller should be set the node type to something else as soon as possible using <a class="el" href="class_a_s_t_node__t.html#a4732ce088dd7bb4fa0542d40fdc72b84" title="Explicitly sets the type of the given ASTNode_t structure. ">ASTNode_setType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the fresh <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a96fa2b9d7071397d474bc1477946c4c0" title="Creates a new ASTNode_t structure and sets its type. ">ASTNode_createWithType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab73896396367d5ed526b93a054f15c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_createFromToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#struct_token__t">Token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure from the given <a class="el" href="group__core.html#struct_token__t" title=" Structure used to store a token returned by FormulaTokenizer_nextToken(). ">Token_t</a> data and returns a pointer to it. </p>
<p>The returned <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure will contain the same data as the <a class="el" href="group__core.html#struct_token__t" title=" Structure used to store a token returned by FormulaTokenizer_nextToken(). ">Token_t</a> structure. The <a class="el" href="group__core.html#struct_token__t" title=" Structure used to store a token returned by FormulaTokenizer_nextToken(). ">Token_t</a> structure is used to store a token returned by <a class="el" href="struct_formula_tokenizer__t.html#aa5775244237e3c9e6907a7b642f1cb0c" title="Returns the next token in the formula string. ">FormulaTokenizer_nextToken()</a>. It contains a union whose members can store different types of tokens, such as numbers and symbols.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the <a class="el" href="group__core.html#struct_token__t" title=" Structure used to store a token returned by FormulaTokenizer_nextToken(). ">Token_t</a> structure to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure. </dd></dl>

</div>
</div>
<a class="anchor" id="a96fa2b9d7071397d474bc1477946c4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_createWithType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure and sets its type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of node to create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the fresh <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a0cb89a516f23169d80f003f292c621c0" title="Creates a new ASTNode_t structure and returns a pointer to it. ">ASTNode_create()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a37">createExampleSBML.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac3dc62036260048545d6ef8a5189d828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_deepCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a recursive copy of a node and all its children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure and all its children. The caller owns the returned structure and is reponsible for deleting it. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fa7f54741734d9d302736a8cb6b31c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode_fillListOfNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list__t.html">List_t</a> *&#160;</td>
          <td class="paramname"><em>lst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of nodes rooted at a given node and satisfying a given predicate. </p>
<p>This method is identical to <a class="el" href="class_a_s_t_node__t.html#a091679cdf3bfecb68e04e76e326f751b" title="Returns a list of nodes rooted at a given node and satisfying a given predicate. ">ASTNode_getListOfNodes()</a>, except that instead of creating a new <a class="el" href="class_list__t.html" title=" Simple, plain, generic lists. ">List_t</a> structure, it uses the one passed in as argument <code>lst</code>. This function performs a depth-first search of the tree rooted at the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure, and adds to <code>lst</code> the nodes for which the given function <code>predicate(node)</code> returns true (i.e., nonzero).</p>
<p>The predicate is passed in as a pointer to a function. The function definition must have the type <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate </a>, which is defined as </p><pre class="fragment">int (*ASTNodePredicate) (const ASTNode_t *node);
</pre><p> where a return value of non-zero represents true and zero represents false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node at which the search is to be started </td></tr>
    <tr><td class="paramname">predicate</td><td>the predicate to use </td></tr>
    <tr><td class="paramname">lst</td><td>the list to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a091679cdf3bfecb68e04e76e326f751b" title="Returns a list of nodes rooted at a given node and satisfying a given predicate. ">ASTNode_getListOfNodes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af5616119e95fab54fe876ac79e595a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure, including any child nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a44">createExampleSBML.c</a>, <a class="el" href="translate_l3_math_8c-example.html#a17">translateL3Math.c</a>, and <a class="el" href="translate_math_8c-example.html#a3">translateMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2ab75b1ed83aa9592e960c8dd3f1717f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_freeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the name field of a given node and sets it to null. </p>
<p>This operation is only applicable to <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structures corresponding to operators, numbers, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. This method will have no effect on other types of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose name field should be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aca93cb10db380ba823ad311d9ddc4008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ASTNode_getCharacter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a node as a single character. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b5febe16514530ccf97536c0a26244d">AST_TIMES</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a11408698b7be79184ba65779128ef654">AST_DIVIDE</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203abfa0a5d49f1a260bab7663cf688e76a9">AST_POWER</a> for the given <code>node</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>node</code> as a single character, or the value <code>CHAR_MAX</code> if <code>is</code> null. </dd></dl>

</div>
</div>
<a class="anchor" id="abc9e764c716ddcfb521ecd254b8305a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a child of a node according to its index number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose child should be obtained. </td></tr>
    <tr><td class="paramname">n</td><td>the index of the desired child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth child of this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> or a null pointer if this node has no nth child (<code>n &gt; </code> ASTNode_getNumChildre() <code>- 1</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a2eca4c9c5fc1a4aee224503c30392d98" title="Returns the number of children of a given node. ">ASTNode_getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac334fd6b6dafa3e5f9dce91cd96d846e" title="Returns the left-most child of a given node. ">ASTNode_getLeftChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a61aa2cefafd840423f93715231007668" title="Returns the right-most child of a given node. ">ASTNode_getRightChild()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a8">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6ea637fa1cb259b3a30d23c07ea229f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ASTNode_getClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML "class" attribute of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose class should be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the class identifier, or null if <code>is</code> a null pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1c9bcb0d60d4e5c7362266be262cb17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes__t.html">XMLAttributes_t</a> * ASTNode_getDefinitionURL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML "definitionURL" attribute value of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "definitionURL" attribute in the form of a libSBML <a class="el" href="class_x_m_l_attributes__t.html" title=" A list of attributes on an XML element. ">XMLAttributes_t</a> structure, or a null pointer if <code>node</code> does not have a value for the attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6a7903fd28aa8694ff78932453bee7da" title="Returns the MathML &quot;definitionURL&quot; attribute value of the given node as a string. ...">ASTNode_getDefinitionURLString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a7903fd28aa8694ff78932453bee7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ASTNode_getDefinitionURLString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML "definitionURL" attribute value of the given node as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "definitionURL" attribute in the form of a string, or a null pointer if <code>node</code> does not have a value for the attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ae1c9bcb0d60d4e5c7362266be262cb17" title="Returns the MathML &quot;definitionURL&quot; attribute value of the given node. ">ASTNode_getDefinitionURL()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc2a8188004b6e23398d7df0f98c0307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode_getDenominator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the numerator value of a node representing a rational number. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a> for the given <code>node</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the denominator of <code>node</code>, or the value <code>LONG_MAX</code> if <code>is</code> null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a06d2acb3cfa5cf15500adc5f1ecb2a55" title="Gets the numerator value of a node representing a rational number. ">ASTNode_getNumerator()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afcc84f170161d8bce106906dc0aab0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode_getExponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the exponent value of a node. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a> for the given <code>node</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the exponent field in the given <code>node</code> <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure, or NaN if <code>is</code> null. </dd></dl>

</div>
</div>
<a class="anchor" id="a22b6741584e916fdadd48d2eef47e281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ASTNode_getId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML "id" attribute of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose identifier should be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identifier of the node, or null if <code>is</code> a null pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a16f09ac9eae29bf5a17e6783f422b7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode_getInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a node as an integer. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> for the given <code>node</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure as a (<code>long</code>) integer, or the value <code>LONG_MAX</code> if <code>is</code> null. </dd></dl>

</div>
</div>
<a class="anchor" id="ac334fd6b6dafa3e5f9dce91cd96d846e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_getLeftChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the left-most child of a given node. </p>
<p>This is equivalent to <code>ASTNode_getChild(node, 0)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose child is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the left child, or a null pointer if there are no children.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a2eca4c9c5fc1a4aee224503c30392d98" title="Returns the number of children of a given node. ">ASTNode_getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#abc9e764c716ddcfb521ecd254b8305a5" title="Gets a child of a node according to its index number. ">ASTNode_getChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a61aa2cefafd840423f93715231007668" title="Returns the right-most child of a given node. ">ASTNode_getRightChild()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a63">createExampleSBML.c</a>, and <a class="el" href="print_math_8c-example.html#a7">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a091679cdf3bfecb68e04e76e326f751b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list__t.html">List_t</a> * ASTNode_getListOfNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of nodes rooted at a given node and satisfying a given predicate. </p>
<p>This function performs a depth-first search of the tree rooted at the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure, and returns a <a class="el" href="class_list__t.html" title=" Simple, plain, generic lists. ">List_t</a> structure of nodes for which the given function <code>predicate(node)</code> returns true (i.e., non-zero).</p>
<p>The predicate is passed in as a pointer to a function. The function definition must have the type <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>, which is defined as </p><pre class="fragment">int (*ASTNodePredicate) (const ASTNode_t *node);
</pre><p> where a return value of nonzero represents true and zero represents false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node at which the search is to be started </td></tr>
    <tr><td class="paramname">predicate</td><td>the predicate to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of nodes for which the predicate returned true (i.e., nonzero). The <a class="el" href="class_list__t.html" title=" Simple, plain, generic lists. ">List_t</a> structure returned is owned by the caller and should be deleted after the caller is done using it. The <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structures in the list, however, are <em>not</em> owned by the caller (as they still belong to the tree itself), and therefore should <em>not</em> be deleted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a9fa7f54741734d9d302736a8cb6b31c3" title="Returns a list of nodes rooted at a given node and satisfying a given predicate. ">ASTNode_fillListOfNodes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af591e133c6243681cc58888de8db0b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode_getMantissa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mantissa value of a node. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a> for the given <code>node</code>. If <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a> for <code>node</code>, this method behaves identically to <a class="el" href="class_a_s_t_node__t.html#a5864c32e5a275746c5c6cd1a05a8782f" title="Get the real-numbered value of a node. ">ASTNode_getReal()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the mantissa of <code>node</code>, or NaN if <code>is</code> null. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1199b7a27ed532f37f0f766bbdcd980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ASTNode_getName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a node as a string. </p>
<p>This function may be called on nodes that (1) are not operators, i.e., nodes for which <a class="el" href="class_a_s_t_node__t.html#acdbe2535bec518e1f7824a485f0ca078" title="Returns true if the given node is a mathematical operator. ">ASTNode_isOperator()</a> returns false (<code>0</code>), and (2) are not numbers, i.e., for which <a class="el" href="class_a_s_t_node__t.html#afe6287e8d5bc16ce683e6dab33b6f604" title="Returns true if the given node contains a number. ">ASTNode_isNumber()</a> also returns false (<code>0</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>node</code> as a string, or a null pointer if <code>is</code> null. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a6">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2eca4c9c5fc1a4aee224503c30392d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ASTNode_getNumChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure whose children are to be counted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of children of <code>node</code>, or <code>0</code> is it has no children. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a5">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a06d2acb3cfa5cf15500adc5f1ecb2a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode_getNumerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the numerator value of a node representing a rational number. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#aad6cd351567a177ab88b961890f18c7c" title="Returns the type of the given node. ">ASTNode_getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a> for the given <code>node</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the numerator of <code>node</code>, or the value <code>LONG_MAX</code> if <code>is</code> null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#acc2a8188004b6e23398d7df0f98c0307" title="Gets the numerator value of a node representing a rational number. ">ASTNode_getDenominator()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50a516cba95b41351a5ce09020f99d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ASTNode_getNumSemanticsAnnotations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of MathML semantic annotations inside the given node. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a count of the semantic annotations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ac58809a0e4fc64a5663ab64c59408092" title="Adds a given XML node structure as a MathML semantic annotation of a given ASTNode_t structure...">ASTNode_addSemanticsAnnotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8272e6ad57d341788869c6b0010c0e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base__t.html">SBase_t</a> * ASTNode_getParentSBMLObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parent SBML structure containing the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the object structure containing the given node. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4329bbf8cd7a2af9e25fa092e5dd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_getPrecedence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the precedence of a node in the infix math syntax of SBML Level&#160;1. </p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas produced by <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and read by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> use a simple C-inspired infix notation taken from SBML Level&#160;1. A formula in this text-string form therefore can be handed to a program that understands SBML Level&#160;1 mathematical expressions, or used as part of a formula translation system. The syntax is described in detail in the documentation for <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>. The following are illustrative examples of formulas expressed using this syntax: <pre class="fragment">0.10 * k4^2
</pre> <pre class="fragment">(vm * s1)/(km + s1)
</pre></dd></dl>
<p>Note that this facility is provided as a convenience by libSBML&mdash;the MathML standard does not actually define a "string-form" equivalent to MathML expression trees, so the choice of formula syntax is somewhat arbitrary. The approach taken by libSBML is to use the syntax defined by SBML Level&#160;1 (which in fact used a text-string representation of formulas and not MathML). This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a * b + c</code> is evaluated as <code>(a * b) + c</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a - b + c</code> is evaluated as <code>(a - b) + c</code> because the <code>+</code> and <code>-</code> operators are left-associative.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters, followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a>:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="35">Args</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td><td><em>x</em></td><td>absolute value of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>acos</code></td><td><em>x</em></td><td>arc cosine of <em>x</em> in radians</td><td>-1.0 &le; <em>x</em> &le; 1.0</td><td>0 &le; <em>acos(x)</em> &le; &pi;</td></tr>
<tr><td><code>asin</code></td><td><em>x</em></td><td>arc sine of <em>x</em> in radians</td><td>-1.0 &le; <em>x</em> &le; 1.0</td><td>0 &le; <em>asin(x)</em> &le; &pi;</td></tr>
<tr><td><code>atan</code></td><td><em>x</em></td><td>arc tangent of <em>x</em> in radians</td><td></td><td>0 &le; <em>atan(x)</em> &le; &pi;</td></tr>
<tr><td><code>ceil</code></td><td><em>x</em></td><td>smallest number not less than <em>x</em> whose value is an exact integer</td><td></td><td></td></tr>
<tr><td><code>cos</code></td><td><em>x</em></td><td>cosine of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>exp</code></td><td><em>x</em></td><td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm</td><td></td><td></td></tr>
<tr><td><code>floor</code></td><td><em>x</em></td><td>largest number not greater than <em>x</em> whose value is an exact integer</td><td></td><td></td></tr>
<tr><td><code>log</code></td><td><em>x</em></td><td>natural logarithm of <em>x</em></td><td><em>x</em> &gt; 0</td><td></td></tr>
<tr><td><code>log10</code></td><td><em>x</em></td><td>base 10 logarithm of <em>x</em></td><td><em>x</em> &gt; 0</td><td></td></tr>
<tr><td><code>pow</code></td><td><em>x, y</em></td><td><em>x</em><sup><em> y</em></sup></td><td></td><td></td></tr>
<tr><td><code>sqr</code></td><td><em>x</em></td><td><em>x</em><sup><em>2</em></sup></td><td></td><td></td></tr>
<tr><td><code>sqrt</code></td><td><em>x</em></td><td>&radic;<em>x</em></td><td><em>x</em> &gt; 0</td><td><em>sqrt(x)</em> &ge; 0</td></tr>
<tr><td><code>sin</code></td><td><em>x</em></td><td>sine of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>tan</code></td><td><em>x</em></td><td>tangent of <em>x</em></td><td>x &ne; n*&pi;/2, for odd integer <em>n</em></td><td></td></tr>
<caption class="bottom-caption">The names of mathematical functions defined in the SBML
Level&nbsp;1 Version&nbsp;2 text-string formula syntax.</caption>
</table>

<dl class="section warning"><dt>Warning</dt><dd><span class="warning">There are differences between the symbols used to represent the common mathematical functions and the corresponding MathML token names. This is a potential source of incompatibilities. Note in particular that in this text-string syntax, <code>log(x)</code> represents the natural logarithm, whereas in MathML, the natural logarithm is <code>&lt;ln/&gt;</code>. Application writers are urged to be careful when translating between text forms and MathML forms, especially if they provide a direct text-string input facility to users of their software systems.</span></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose precedence is to be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the precedence of <code>node</code> (as defined in the SBML Level&#160;1 specification). </dd></dl>

</div>
</div>
<a class="anchor" id="a5864c32e5a275746c5c6cd1a05a8782f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode_getReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real-numbered value of a node. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node__t.html#af427afbdd9272f8b410b46ed04b9c2e1" title="Returns true if the given node represents a real number. ">ASTNode_isReal()</a> returns non-zero for <code>node</code>. This function performs the necessary arithmetic if the node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> (<em>mantissa * 10<sup> exponent</sup></em>) or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a> (<em>numerator / denominator</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>node</code> as a real (double), or NaN if <code>is</code> null. </dd></dl>

</div>
</div>
<a class="anchor" id="a61aa2cefafd840423f93715231007668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * ASTNode_getRightChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the right-most child of a given node. </p>
<p>If <code>ASTNode_getNumChildren(node) &gt; 1</code>, then this is equivalent to: </p><pre class="fragment">ASTNode_getChild(node, ASTNode_getNumChildren(node) - 1);
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose child node is to be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the right child of <code>node</code>, or a null pointer if <code>node</code> has no right child.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a2eca4c9c5fc1a4aee224503c30392d98" title="Returns the number of children of a given node. ">ASTNode_getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac334fd6b6dafa3e5f9dce91cd96d846e" title="Returns the left-most child of a given node. ">ASTNode_getLeftChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#abc9e764c716ddcfb521ecd254b8305a5" title="Gets a child of a node according to its index number. ">ASTNode_getChild()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a64">createExampleSBML.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af95a264af5522e4b2449f89f86d342d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node__t.html">XMLNode_t</a> * ASTNode_getSemanticsAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nth MathML semantic annotation attached to the given node. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query </td></tr>
    <tr><td class="paramname">n</td><td>the index of the semantic annotation to fetch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth semantic annotation on <code>node</code> , or a null pointer if the node has no nth annotation (which would mean that <code>n &gt; ASTNode_getNumSemanticsAnnotations(node) - 1</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ac58809a0e4fc64a5663ab64c59408092" title="Adds a given XML node structure as a MathML semantic annotation of a given ASTNode_t structure...">ASTNode_addSemanticsAnnotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70d069697b1f126d9773d17e9bba45c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ASTNode_getStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML "style" attribute of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representing the "style" value, or a null value if <code>is</code> a null pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="aad6cd351567a177ab88b961890f18c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> ASTNode_getType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure. </dd></dl>

</div>
</div>
<a class="anchor" id="a58ab5e06e28d25076d2c09674f538861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ASTNode_getUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SBML "units" attribute of a given node. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose units are to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the units, as a string, or a null value if <code>is</code> a null pointer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute for MathML expressions is only defined in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a463cba3c511f0836df7b4e7e15e474eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ASTNode_getUserData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user data associated with this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user data of this node, or a null pointer if no user data has been set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#aea8c4b2b0ef0fb780f3214ad1bd4a892" title="Sets the user data of the given node. ">ASTNode_setUserData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42db011a3bf7aacb62d13fe0f9d1b2c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode_getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the numerical value of this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> whose value is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numerical value of this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>, or <code>NaN</code> if this is not a type of node that has a numerical value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will return a numerical value (as a double) for any <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> that represents a number, a constant such as pi or avogadro or <code>1</code> for nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ad571d2b80f4dcc08fc489960efdb2ab3">AST_CONSTANT_TRUE</a> and <code>0</code> for nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adc46a568eb6b891f72738b67da24347a">AST_CONSTANT_FALSE</a>. It does not evaluate the node in any way so, for example, it will not return the value of a named <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> or attempt to evaluate a function. This includes a node representing <code>time</code> i.e. nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a0358231b02f7964269ebb2e580defdf2">AST_NAME_TIME</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a62a3e3926d142fad871af6a9ae8e4009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_hasCorrectNumberArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node has the correct number of children for its type. </p>
<p>For example, an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure with type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a> expects 2 child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> has the appropriate number of children for its type, <code>0</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs a check on the top-level node only. Child nodes are not checked.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ef78fafa2b08f693bf681aaab77302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_hasTypeAndNumChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numchildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is of a specific type and has a specific number of children. </p>
<p>This function is designed for use in cases such as when callers want to determine if the node is a unary <code>not</code> or unary <code>minus</code>, or a <code>times</code> node with no children, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query </td></tr>
    <tr><td class="paramname">type</td><td>the type that the node should have </td></tr>
    <tr><td class="paramname">numchildren</td><td>the number of children that the node should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is has the specified type and number of children, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aab42b3d9d1da048db4f9fa7e8f8789fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_hasUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node or any of its children have the SBML "units" attribute set. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the attribute is set, <code>0</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ab6968a1543fd93af358ff83406f300d3" title="Returns true if this node&#39;s SBML &quot;units&quot; attribute is set. ">ASTNode_isSetUnits()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a364665c627b2d76e8d7bad21bd6778a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_insertChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node at a given point in the list of children of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure to modify. </td></tr>
    <tr><td class="paramname">n</td><td>unsigned int the index of the location where the <code>disownedChild</code> is to be added. </td></tr>
    <tr><td class="paramname">disownedChild</td><td><a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure to insert as the nth child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8" title="Adds a node as a child of another node. ">ASTNode_addChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0" title="Adds a node as a child of another node. ">ASTNode_prependChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9" title="Replaces the nth child of a given node. ">ASTNode_replaceChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756" title="Removes the nth child of a given node. ">ASTNode_removeChild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b19607769e3366ae509810b9d0dc78f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isAvogadro </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents the special symbol <code>avogadro</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if this stands for <code>avogadro</code>, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a674a4db8d06d9b097f401e4416921682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isBoolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is some type of Boolean value or operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node in question</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if <code>node</code> is a Boolean (a logical operator, a relational operator, or the constants <code>true</code> or <code>false</code>), <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a41693ed536a3f8ed0cf8ced72648e3a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a MathML constant. </p>
<p>Examples of constants in this context are <code>Pi</code>, <code>true</code>, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a MathML constant, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a27ffa52569effd80dc4c8f05b10cceae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isConstantNumber </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a MathML constant. </p>
<p>Examples of constants in this context are <code>Pi</code>, <code>true</code>, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a MathML constant, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a75a5d3a61ee280376764fab101b55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a function in SBML, whether predefined (in SBML Level&#160;1), defined by MathML (SBML Levels&#160;2&ndash;3) or user-defined. </dd></dl>

</div>
</div>
<a class="anchor" id="affbff513dc3ed651f3dd4b6b15542ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isInfinity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node stands for infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is the special IEEE 754 value for infinity, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a01d6f0edbf9724b3192227bd8449103c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node contains an integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a33453c3da65b164abcd98e9167297ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isLambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is a MathML lambda function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f024e470c75d099b1ecb8b368d6af5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isLog10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents the log base-10 function. </p>
<p>More precisely, this function tests if the given <code>node's</code> type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aee5ce31deca83c9d96a5888474bc0e4d">AST_FUNCTION_LOG</a> with two children, the first of which is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> equal to <code>10</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> represents a log10() function, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a023b6d785bf900a974168d2ea14fa9dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isLogical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is a logical operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a MathML logical operator (<code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>), <code>0otherwise</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c3d6437704c3b688cbf71a0f10928a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is a named entity. </p>
<p>More precisely, this returns a true value if <code>node</code> is a user-defined variable name or the special symbols <code>time</code> or <code>avogadro</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a named variable, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="affb58317547d8879e92a03977c7cf675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isNaN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents not-a-number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is the special IEEE 754 value NaN ("not a
number"), <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8af4f898abcbf4dbcd9edc066abe0f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isNegInfinity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents negative infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is the special IEEE 754 value negative infinity, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#affbff513dc3ed651f3dd4b6b15542ce5" title="Returns true if the given node stands for infinity. ">ASTNode_isInfinity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afe6287e8d5bc16ce683e6dab33b6f604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isNumber </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node contains a number. </p>
<p>This is functionally equivalent to: </p><pre class="fragment">ASTNode_isInteger(node) || ASTNode_isReal(node).
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a number, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acdbe2535bec518e1f7824a485f0ca078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isOperator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is a mathematical operator. </p>
<p>The possible mathematical operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>^</code> (power).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is an operator, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0af7bdc5097da065ece0a84941796dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isPiecewise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents the MathML <code>&lt;piecewise&gt;</code> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is the MathML piecewise function, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6937df6eea839c0bfc5c58b672448f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isRational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a rational number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af427afbdd9272f8b410b46ed04b9c2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a real number. </p>
<p>More precisely, this node must be of one of the following types: <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value of <code>node</code> can represent a real number, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abd44dcefb47d8f289fee176c8cbb8f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isRelational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a MathML relational operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a MathML relational operator, meaning <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d268b1f14bac28726f29148cfe104a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node's MathML "class" attribute is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the attribute is set, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a50c11df4c38a28db8f3fc8107c5efdc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node's MathML "id" attribute is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if it is set, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fb45cff1b064de4ad3d73556a64b2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetParentSBMLObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node's parent SBML object is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the parent SBML object is set, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a73d72e8d3de6ba6ae9dabf6dd3520c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node's MathML "style" attribute is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the attribute is set, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6968a1543fd93af358ff83406f300d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node's SBML "units" attribute is set. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the attribute is set, <code>0</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML. </dd></dl>

</div>
</div>
<a class="anchor" id="acea40c2df7746f001929b47c627a8a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSetUserData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node's user data object is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the user data object is set, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#aea8c4b2b0ef0fb780f3214ad1bd4a892" title="Sets the user data of the given node. ">ASTNode_setUserData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a064aa38d489440911cdeb49d0bba38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isSqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is the MathML square-root operator. </p>
<p>More precisely, the node type must be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a676272161183a845f1fb3cdcf02fea63">AST_FUNCTION_ROOT</a> with two children, the first of which is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> node having value equal to 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> represents a sqrt() function, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac050df5b95a4bc6d8d4c525321ac3116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isUMinus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node represents a unary minus. </p>
<p>A node is defined as a unary minus node if it is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a> and has exactly one child.</p>
<p>For numbers, unary minus nodes can be "collapsed" by negating the number. In fact, <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> does this during its parsing process, and <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> has a configuration option that allows this behavior to be turned on or off. However, unary minus nodes for symbols (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a>) cannot be "collapsed", so this predicate function is still necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a unary minus, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d51d09179e715254bc2c5b1526d8c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isUnknown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the type of the node is unknown. </p>
<p>"Unknown" nodes have the type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. Nodes with unknown types will not appear in an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> tree returned by libSBML based upon valid SBML input; the only situation in which a node with type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a> may appear is immediately after having create a new, untyped node using the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> constructor. Callers creating nodes should endeavor to set the type to a valid node type as soon as possible after creating new nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is of type <code>AST_UNKNOWN</code>, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e10ad3a7a5e9412a4034e5de0becc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isUPlus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is a unary plus. </p>
<p>A node is defined as a unary minus node if it is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a> and has exactly one child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is a unary plus, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aee8007ec76f0f38d289446ada912dbb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_isWellFormedASTNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is well-formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> is well-formed, <code>0</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> may be well-formed, with each node and its children having the appropriate number of children for the given type, but may still be invalid in the context of its use within an SBML model. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2ee0ff04953bf084bd159e1cbda69f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_prependChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node as a child of another node. </p>
<p>This method adds child nodes from right to left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node that will receive the given child node. </td></tr>
    <tr><td class="paramname">disownedChild</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> instance to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8" title="Adds a node as a child of another node. ">ASTNode_addChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9" title="Replaces the nth child of a given node. ">ASTNode_replaceChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1" title="Insert a new child node at a given point in the list of children of a node. ">ASTNode_insertChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756" title="Removes the nth child of a given node. ">ASTNode_removeChild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a968f1b2488e4e6f3d49c1567fefbeedc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode_reduceToBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the given node to a binary true. </p>
<p>Example: if <code>node</code> is <code>and(x, y, z)</code>, then the formula of the reduced node is <code>and(and(x, y), z)</code>. The operation replaces the formula stored in the current <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73a7c454ed9dbe23fc9a2385aee29756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth child of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node whose child element is to be removed. </td></tr>
    <tr><td class="paramname">n</td><td>unsigned int the index of the child to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8" title="Adds a node as a child of another node. ">ASTNode_addChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0" title="Adds a node as a child of another node. ">ASTNode_prependChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9" title="Replaces the nth child of a given node. ">ASTNode_replaceChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1" title="Insert a new child node at a given point in the list of children of a node. ">ASTNode_insertChild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a802619e15437b7fdc85c4da9ef6c3c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_replaceAndDeleteChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces and deletes the nth child of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> node to modify </td></tr>
    <tr><td class="paramname">n</td><td>unsigned int the index of the child to replace </td></tr>
    <tr><td class="paramname">disownedChild</td><td><a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure to replace the nth child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8" title="Adds a node as a child of another node. ">ASTNode_addChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0" title="Adds a node as a child of another node. ">ASTNode_prependChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1" title="Insert a new child node at a given point in the list of children of a node. ">ASTNode_insertChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756" title="Removes the nth child of a given node. ">ASTNode_removeChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa7c1c97f78efe675e96ae34b11b4dae9" title="Replaces the nth child of a given node. ">ASTNode_replaceChild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22cf806f71c75d7af5df9c83a3ded9dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode_replaceArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences of a given name with a new <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure. </p>
<p>For example, if the formula in <code>node</code> is <code>x + y</code>, then the <code>&lt;bvar&gt;</code> is <code>x</code> and <code>arg</code> is an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure representing the real value <code>3</code>. This function substitutes <code>3</code> for <code>x</code> within the <code>node</code> <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">bvar</td><td>the MathML <code>&lt;bvar&gt;</code> to use </td></tr>
    <tr><td class="paramname">arg</td><td>the replacement node or structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7c1c97f78efe675e96ae34b11b4dae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_replaceChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the nth child of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> node to modify </td></tr>
    <tr><td class="paramname">n</td><td>unsigned int the index of the child to replace </td></tr>
    <tr><td class="paramname">disownedChild</td><td><a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure to replace the nth child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The method <a class="el" href="class_a_s_t_node__t.html#aee8007ec76f0f38d289446ada912dbb6" title="Returns true if the given node is well-formed. ">ASTNode_isWellFormedASTNode()</a> may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6325eec724b979c5c181dc948baa76a8" title="Adds a node as a child of another node. ">ASTNode_addChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae2ee0ff04953bf084bd159e1cbda69f0" title="Adds a node as a child of another node. ">ASTNode_prependChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a364665c627b2d76e8d7bad21bd6778a1" title="Insert a new child node at a given point in the list of children of a node. ">ASTNode_insertChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a73a7c454ed9dbe23fc9a2385aee29756" title="Removes the nth child of a given node. ">ASTNode_removeChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a802619e15437b7fdc85c4da9ef6c3c04" title="Replaces and deletes the nth child of a given node. ">ASTNode_replaceAndDeleteChild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0b0073a3b87eb4eb6371fa62dd047b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_returnsBoolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is something that returns a Boolean value. </p>
<p>This function looks at the whole <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure rather than just the top level of <code>node</code>. Thus, it will consider return values from MathML <code>piecewise</code> statements. In addition, if the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure in <code>node</code> uses a function call, this function will examine the return value of the function. Note that this is only possible in cases the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure can trace its parent <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> structure; that is, the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure must represent the <code>&lt;math&gt;</code> element of some SBML object that has already been added to an instance of an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> returns a boolean, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a674a4db8d06d9b097f401e4416921682" title="Returns true if this node is some type of Boolean value or operator. ">ASTNode_isBoolean()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a268c005348494077d1963e8475131797" title="Returns true if the given node is something that returns a Boolean value. ">ASTNode_returnsBooleanForModel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a268c005348494077d1963e8475131797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_returnsBooleanForModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_model__t.html">Model_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is something that returns a Boolean value. </p>
<p>This function looks at the whole <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure rather than just the top level of <code>node</code>. Thus, it will consider return values from MathML <code>piecewise</code> statements. In addition, if the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure in <code>node</code> uses a function call, this function will examine the return value of the function using the definition of the function found in the given <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> structure given by <code>model</code> (rather than the model that might be traced from <code>node</code> itself). This function is similar to <a class="el" href="class_a_s_t_node__t.html#af0b0073a3b87eb4eb6371fa62dd047b5" title="Returns true if the given node is something that returns a Boolean value. ">ASTNode_returnsBoolean()</a>, but is useful in situations where the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure has not been hooked into a model yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to query </td></tr>
    <tr><td class="paramname">model</td><td>the model to use as the basis for finding the definition of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>node</code> returns a boolean, <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a674a4db8d06d9b097f401e4416921682" title="Returns true if this node is some type of Boolean value or operator. ">ASTNode_isBoolean()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#af0b0073a3b87eb4eb6371fa62dd047b5" title="Returns true if the given node is something that returns a Boolean value. ">ASTNode_returnsBoolean()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5442e365c7d5e804734963429c1bcf4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setCharacter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given node to a character. </p>
<p>If character is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> or <code>^</code>, the node type will be set accordingly. For all other characters, the node type will be set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">value</td><td>the character value for the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9233c21f7c65a409e7bc1c63121e6ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>className</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML "class" of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">className</td><td>the new value for the "class" attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9e652d935fa0e613bb2c77e5fb74bd59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setDefinitionURL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_attributes__t.html">XMLAttributes_t</a> *&#160;</td>
          <td class="paramname"><em>defnURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML "definitionURL" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">defnURL</td><td>the value to which the attribute should be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae03905b1eb04d9770aa0fb9342405f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setDefinitionURLString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defnURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML "definitionURL" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">defnURL</td><td>a string to which the attribute should be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aed906c880e0fdd89491cdbc2f3d979ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML "id" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">id</td><td>the identifier to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a394a038735e0acea492477553e2b4785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the given node to a integer and sets it type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">value</td><td>the value to set it to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aae71126053a0e83f8c11d7f7e0b68a62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the node to represent a named entity. </p>
<p>As a side-effect, this <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> object's type will be reset to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> if (and <em>only if</em>) the <code>node</code> was previously an operator (i.e., <a class="el" href="class_a_s_t_node__t.html#acdbe2535bec518e1f7824a485f0ca078" title="Returns true if the given node is a mathematical operator. ">ASTNode_isOperator()</a> returns true), number (i.e., <a class="el" href="class_a_s_t_node__t.html#afe6287e8d5bc16ce683e6dab33b6f604" title="Returns true if the given node contains a number. ">ASTNode_isNumber()</a> returns true), or unknown. This allows names to be set for <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> nodes and the like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">name</td><td>the name value for the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a39">createExampleSBML.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad37f9ccf735798998550dee4edfe1dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setRational </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given node to a rational number and sets its type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">numerator</td><td>the numerator value to use </td></tr>
    <tr><td class="paramname">denominator</td><td>the denominator value to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6122c93db7afa2f28ba62e1eac46efba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setReal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given node to a real (<code>double</code>) and sets its type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>. </p>
<p>This is functionally equivalent to: </p><pre class="fragment">ASTNode_setRealWithExponent(node, value, 0);
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">value</td><td>the value to set the node to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a23ddacc52b27b5466bb6c8b0c526984f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setRealWithExponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mantissa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given node to a real (<code>double</code>) in two parts, a mantissa and an exponent. </p>
<p>As a side-effect, the <code>node's</code> type will be set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">mantissa</td><td>the mantissa of this node's real-numbered value </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent of this node's real-numbered value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1adc9d1999c4e90503a10315cb26fda7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML "style" of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">style</td><td>the new value for the "style" attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4732ce088dd7bb4fa0542d40fdc72b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly sets the type of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to set </td></tr>
    <tr><td class="paramname">type</td><td>the new type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A side-effect of doing this is that any numerical values previously stored in this node are reset to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2ba54073600b30a5e248ca6b288db2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the units of the given node. </p>
<p>The units will be set <em>only</em> if the <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> object in <code>node</code> represents a MathML <code>&lt;cn&gt;</code> element, i.e., represents a number. Callers may use <a class="el" href="class_a_s_t_node__t.html#afe6287e8d5bc16ce683e6dab33b6f604" title="Returns true if the given node contains a number. ">ASTNode_isNumber()</a> to inquire whether the node is of that type.</p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">units</td><td>the units to set it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML. </dd></dl>

</div>
</div>
<a class="anchor" id="aea8c4b2b0ef0fb780f3214ad1bd4a892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_setUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the user data of the given node. </p>
<p>The user data can be used by the application developer to attach custom information to the node. In case of a deep copy, this attribute will passed as it is. The attribute will be never interpreted by this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify </td></tr>
    <tr><td class="paramname">userData</td><td>the new user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a463cba3c511f0836df7b4e7e15e474eb" title="Returns the user data associated with this node. ">ASTNode_getUserData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e710c2223c9488bbb751c69d07ee689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_swapChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>that</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the children of two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
    <tr><td class="paramname">that</td><td>the other node whose children should be used to replace those of <code>node</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3fb034919598e8d3bf7e2a1cd21a6c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_unsetClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML "class" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a38aa72a2d49306bbaf046197a4128b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_unsetId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML "id" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a19c441a24228ee0b7b1246dba67d5b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_unsetStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML "style" attribute of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af2244b486a1a104b14639602feec5340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_unsetUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the units associated with the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a132dd4d210148145e8db749668ea0091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode_unsetUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the user data of the given node. </p>
<p>The user data can be used by the application developer to attach custom information to the node. In case of a deep copy, this attribute will passed as it is. The attribute will be never interpreted by this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a463cba3c511f0836df7b4e7e15e474eb" title="Returns the user data associated with this node. ">ASTNode_getUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aea8c4b2b0ef0fb780f3214ad1bd4a892" title="Sets the user data of the given node. ">ASTNode_setUserData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f358b912b5d2479e7184d1f657d5819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * readMathMLFromString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree, and returns a pointer to the root of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml</td><td>a string containing a full MathML expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root of an AST corresponding to the given mathematical expression, otherwise <code>NULL</code> is returned if the given string is <code>NULL</code> or invalid. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8c-example.html#a50">createExampleSBML.c</a>, <a class="el" href="translate_l3_math_8c-example.html#a18">translateL3Math.c</a>, and <a class="el" href="translate_math_8c-example.html#a4">translateMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a52e588cb2afd2cabd317ea70f10b3c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * readMathMLFromStringWithNamespaces </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_namespaces__t.html">XMLNamespaces_t</a> *&#160;</td>
          <td class="paramname"><em>xmlns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree, and returns a pointer to the root of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml</td><td>a string containing a full MathML expression </td></tr>
    <tr><td class="paramname">xmlns</td><td>an <a class="el" href="class_x_m_l_namespaces__t.html" title=" An XML Namespace. ">XMLNamespaces_t</a> structure containing namespaces that are considered active during the read. (For example, an SBML Level&#160;3 package namespace.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root of an AST corresponding to the given mathematical expression, otherwise <code>NULL</code> is returned if the given string is <code>NULL</code> or invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="afac029dddfabae36ca83d8091739cd88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * SBML_formulaToL3String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1, but extended to include elements from SBML Level&#160;2 and SBML Level&#160;3. </p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas read by the function <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> and written by the function <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> uses an expanded version of the syntax read and written by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> and <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>, respectively. The latter two libSBML functions were originally developed to support conversion between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of mathematical formulas used in SBML Level&#160;1. With time, and the use of MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for software developers. To maintain backwards compatibility for libSBML users, the original <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> have been left untouched, and instead, the new functionality is provided in the form of <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> and <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a>.</dd></dl>
<p>The following lists the main differences in the formula syntax supported by the Level 3 ("L3") versions of the formula parsers and formatters, compared to what is supported by the Level&#160;1-oriented <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> and <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>:</p>
<ul>
<li>Units may be asociated with bare numbers, using the following syntax: <div style="margin: 10px auto 10px 25px; display: block"> <span class="code" style="background-color: #d0d0ee">number</span> <span class="code" style="background-color: #edd">unit</span> </div> The <span class="code" style="background-color: #d0d0ee">number</span> may be in any form (an integer, real, or rational number), and the <span class="code" style="background-color: #edd">unit</span> must conform to the syntax of an SBML identifier (technically, the type defined as <code>SId</code> in the SBML specifications). The whitespace between <span class="code" style="background-color: #d0d0ee">number</span> and <span class="code" style="background-color: #edd">unit</span> is optional.</li>
</ul>
<ul>
<li>The Boolean function symbols <code>&amp;&amp;</code> (<em>and</em>), <code>||</code> (<em>or</em>), <code>!</code> (<em>not</em>), and <code>!=</code> (<em>not</em> <em>equals</em>) may be used.</li>
</ul>
<ul>
<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and will produce a <code>&lt;piecewise&gt;</code> function in the corresponding MathML output by default, or can produce the MathML function <code>rem</code>, depending on the <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object (see <a class="el" href="class_l3_parser_settings__t.html#ae561a89e47171456f376e158b6e541d1" title="Sets the behavior for handling the &#39;&#39; sumbol in mathematical formulas. ">L3ParserSettings_setParseModuloL3v2()</a> ).</li>
</ul>
<ul>
<li>All inverse trigonometric functions may be defined in the infix either using <code>arc</code> as a prefix or simply <code>a</code>; in other words, both <code>arccsc</code> and <code>acsc</code> are interpreted as the operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions in the simpler SBML Level&#160;1 oriented parser implemented by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> are defined this way as well, but not all.)</li>
</ul>
<ul>
<li>The following expression is parsed as a rational number instead of as a numerical division: <pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre> <b>Spaces are not allowed</b> in this construct; in other words, &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the operator) will be parsed into the MathML <code>&lt;divide&gt;</code> construct rather than a rational number. You can, however, assign units to a rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;. (In the case of division rather than a rational number, units are not interpreted in this way.)</li>
</ul>
<ul>
<li>Various parser and formatter behaviors may be altered through the use of a <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object in conjunction with the functions <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToL3StringWithSettings()</a> The settings available include the following: <ul style="list-style-type: circle">
<li style="margin-bottom: 0.5em">
<p class="startli">The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Unary minus signs can be collapsed or preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input entirely and single unary minuses can be incorporated into the number node, or all minuses can be preserved in the AST node structure.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Parsing of units embedded in the input string can be turned on and off.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string <code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an identifier.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string % can be parsed either as a piecewise function or as the 'rem' function: <code>a % b</code> will either become</p>
<p><code>piecewise(a - b*ceil(a/b), xor((a &lt; 0), (b &lt; 0)), a - b*floor(a/b))</code></p>
<p>or</p>
<p><code>rem(a, b)</code>.</p>
<p>The latter is simpler, but the <code>rem</code> MathML is only allowed as of SBML Level&#160;3 Version&#160;2.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">A <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object may optionally be provided to the parser using the variant function call <a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> or stored in a <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object passed to the variant function <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. When a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is provided, identifiers (values of type <code>SId</code> ) from that model are used in preference to pre-defined MathML definitions for both symbols and functions. More precisely: </p><ul style="list-style-type: square">
<li style="margin-bottom: 0.5em">
<p class="startli"><em>In the case of symbols</em>: the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a>, <a class="el" href="class_compartment__t.html" title=" An SBML compartment, where species are located. ">Compartment_t</a>, <a class="el" href="class_parameter__t.html" title=" An SBML parameter: a named symbol with a value. ">Parameter_t</a>, <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a>, and <a class="el" href="class_species_reference__t.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference_t</a>. For instance, if the parser is given a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> containing a <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<em>In the case of user-defined functions</em>: when a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is provided, <code>SId</code> values of user-defined functions present in the model will be used preferentially over pre-defined MathML functions. For example, if the passed-in <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> contains a <a class="el" href="class_function_definition__t.html" title=" A user-defined function in an SBML model. ">FunctionDefinition_t</a> object with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
</ul>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
An <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> object may optionally be provided to identify SBML Level&#160;3 packages that extend the syntax understood by the formula parser. When the namespaces are provided, the parser will interpret possible additional syntax defined by the libSBML plug-ins implementing the SBML Level&#160;3 packages; for example, it may understand vector/array extensions introduced by the SBML Level&#160;3 <em>Arrays</em> package. </li>
</ul>
</li>
</ul>
<p>These configuration settings cannot be changed directly using the basic parser and formatter functions, but <em>can</em> be changed on a per-call basis by using the alternative functions <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToL3StringWithSettings()</a>.</p>
<p>Neither SBML nor the MathML standard define a "string-form" equivalent to MathML expressions. The approach taken by libSBML is to start with the formula syntax defined by SBML Level&#160;1 (which in fact used a custom text-string representation of formulas, and not MathML), and expand it to include the functionality described above. This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors"
       style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Preced.</th>
     <th align="left">Assoc.</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">8</td><td>left</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">7</td><td>left</td></tr>
<tr><td><code>-, !</code></td><td>negation, Boolean 'not'</td><td>unary</td><td align="center">6</td><td>right</td></tr>
<tr><td><code>*, /, %</code></td><td>multip., div., modulo</td><td>binary</td><td align="center">5</td><td>left</td></tr>
<tr><td><code>+, -</code></td><td>addition and subtraction</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>==, &lt;, &gt;, &lt;=, &gt;=, !=</code></td><td>Boolean comparisons</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>&&, ||</code></td><td>Boolean 'and' and 'or'</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>

<caption class="top-caption">Expression operators and their precedence in the
"Level&nbsp;3" text-string format for mathematical expressions.
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as <code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and <code>||</code> operators are left-associative and have the same precedence.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with additions based on the functions added in SBML Level 2 and Level 3:</p>
<table border="0" width="95%" 
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="75">Argument(s)</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td>   
    <td><em>x</em></td> 
    <td>Absolute value of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acos</code>, <code>arccos</code></td>
    <td><em>x</em></td>
    <td>Arccosine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>acos(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>acosh</code>, <code>arccosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosine of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acot</code>, <code>arccot</code></td>
    <td><em>x</em></td>
    <td>Arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acoth</code>, <code>arccoth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsc</code>, <code>arccsc</code></td>
    <td><em>x</em></td>
    <td>Arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsch</code>, <code>arccsch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asec</code>, <code>arcsec</code></td>
    <td><em>x</em></td>
    <td>Arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asech</code>, <code>arcsech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asin</code>, <code>arcsin</code></td>
    <td><em>x</em></td><td>Arcsine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>asin(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atan</code>, <code>arctan</code></td>
    <td><em>x</em></td>
    <td>Arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td>0 &le; <em>atan(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atanh</code>, <code>arctanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ceil</code>, <code>ceiling</code></td>
    <td><em>x</em></td>
    <td>Smallest number not less than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cos</code></td>
    <td><em>x</em></td>
    <td>Cosine of <em>x</em></td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cot</code></td>
    <td><em>x</em></td>
    <td>Cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>coth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csc</code></td>
    <td><em>x</em></td>
    <td>Cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>delay</code></td>
    <td><em>x, y</em></td>
    <td>The value of <em>x</em> at <em>y</em> time units in the past.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>factorial</code></td>
    <td><em>n</em></td>
    <td>The factorial of <em>n</em>. Factorials are defined by <em>n! = n*(n&ndash;1)* ... * 1</em>.</td>
    <td><em>n</em> must be an integer.</td>
    <td></td>
</tr>
<tr><td><code>exp</code></td>
    <td><em>x</em></td>
    <td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>floor</code></td>
    <td><em>x</em></td>
    <td>The largest number not greater than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ln</code></td>
    <td><em>x</em></td>
    <td>Natural logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x</em></td>
    <td>By default, the base 10 logarithm of <em>x</em>, but can be set to be the natural logarithm of <em>x</em>, or to be an illegal construct.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x, y</em></td>
    <td>The base <em>x</em> logarithm of <em>y</em>.</td>
    <td><em>y</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log10</code></td>
    <td><em>x</em></td>
    <td>Base 10 logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>piecewise</code></td>
    <td><em>x1, y1, [x2, y2,] [...] [z]</em></td>
    <td>A piecewise function: if (<em>y1</em>), <em>x1</em>.  Otherwise, if (<em>y2</em>), <em>x2</em>, etc.  Otherwise, z. </td>
    <td><em>y1, y2, y3 [etc]</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>pow</code>, <code>power</code> </td>
    <td><em>x, y</em></td>
    <td><em>x</em><sup><em> y</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>root</code></td>
    <td><em>b, x</em></td>
    <td>The root base <em>b</em> of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sec</code></td>
    <td><em>x</em></td>
    <td>Secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqr</code></td>
    <td><em>x</em></td>
    <td><em>x</em><sup><em>2</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqrt</code></td>
    <td><em>x</em></td>
    <td>&radic;<em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td><em>sqrt(x)</em> &ge; 0</td>
</tr>
<tr><td><code>sin</code></td>
    <td><em>x</em></td>
    <td>Sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sinh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>tan</code></td>
    <td><em>x</em></td>
    <td>Tangent of <em>x</em>.</td>
    <td>x &ne; n*&pi;/2, for odd integer <em>n</em></td>
    <td></td>
</tr>
<tr><td><code>tanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic tangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>and</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>and(x, y, z...)</em>: returns <code>true</code> if all of its arguments are true.  Note that <code>and</code> is an n-ary function, taking 0 or more arguments, and that <code>and()</code> returns <code>true</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>not</code></td>
    <td><em>x</em></td>
    <td>Boolean <em>not(x)</em></td>
    <td><em>x</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>or</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>or(x, y, z...)</em>: returns <code>true</code> if at least one of its arguments is true.  Note that <code>or</code> is an n-ary function, taking 0 or more arguments, and that <code>or()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>xor</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>xor(x, y, z...)</em>: returns <code>true</code> if an odd number of its arguments is true.  Note that <code>xor</code> is an n-ary function, taking 0 or more arguments, and that <code>xor()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>eq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>eq(x, y, z...)</em>: returns <code>true</code> if all arguments are equal.  Note that <code>eq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>geq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>geq(x, y, z...)</em>: returns <code>true</code> if each argument is greater than or equal to the argument following it.  Note that <code>geq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>gt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>gt(x, y, z...)</em>: returns <code>true</code> if each argument is greater than the argument following it.  Note that <code>gt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>leq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>leq(x, y, z...)</em>: returns <code>true</code> if each argument is less than or equal to the argument following it.  Note that <code>leq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>lt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>lt(x, y, z...)</em>: returns <code>true</code> if each argument is less than the argument following it.  Note that <code>lt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>neq</code></td>
    <td><em>x, y</em></td>
    <td>Boolean <em>x</em> != <em>y</em>: returns <code>true</code> unless x and y are equal.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>plus</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> + <em>y</em> + <em>z</em> + <em>...</em>: The sum of the arguments of the function.  Note that <code>plus</code> is an n-ary function taking 0 or more arguments, and that <code>plus()</code> returns <code>0</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>times</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> * <em>y</em> * <em>z</em> * <em>...</em>: The product of the arguments of the function.  Note that <code>times</code> is an n-ary function taking 0 or more arguments, and that <code>times()</code> returns <code>1</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>minus</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> &ndash; <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>divide</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> / <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>

<caption class="top-caption">Mathematical functions defined
in the "Level&nbsp;3" text-string formula syntax.</caption>

</table>

<p>Parsing of the various MathML functions and constants are all case-insensitive by default: function names such as <code>cos</code>, <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine operator, <code>&lt;cos&gt;</code>. However, <em>when a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is used</em> in conjunction with either <a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> or <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>, any identifiers found in that model will be parsed in a case-<em>sensitive</em> way. For example, if a model contains a <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a> having the identifier <code>Pi</code>, the parser will parse &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi &lt;/ci&gt;</code>&quot; but will continue to parse the symbols &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as &quot;<code>&lt;pi&gt;</code>&quot;.</p>
<p>As mentioned above, the manner in which the "L3" versions of the formula parser and formatter interpret the function &quot;<code>log</code>&quot; can be changed. To do so, callers should use the function <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and pass it an appropriate <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object. By default, unlike the SBML Level&#160;1 parser implemented by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a>, the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10 logarithm, and <em>not</em> as the natural logarithm. However, you can change the interpretation to be base-10 log, natural log, or as an error; since the name "log" by itself is ambiguous, you require that the parser uses <code>log10</code> or <code>ln</code> instead, which are more clear. Please refer to <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>.</p>
<p>In addition, the following symbols will be translated to their MathML equivalents, if no symbol with the same <code>SId</code> identifier string exists in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object provided:</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="250">Meaning</th>
     <th align="left">MathML</th>
 </tr>
<tr><td><code>true</code></td>   
    <td>Boolean value <code>true</code></td>
    <td><code>&lt;true/&gt;</code></td>
</tr>
<tr><td><code>false</code></td>   
    <td>Boolean value <code>false</code></td>
    <td><code>&lt;false/&gt;</code></td>
</tr>
<tr><td><code>pi</code></td>   
    <td>Mathematical constant pi</td>
    <td><code>&lt;pi/&gt;</code></td>
</tr>
<tr><td><code>avogadro</code></td>   
    <td>Value of Avogadro's constant stipulated by SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/avogadro"&gt; avogadro &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>time</code></td>   
    <td>Simulation time as defined in SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/time"&gt; time &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>inf</code>, <code>infinity</code></td>   
    <td>Mathematical constant "infinity"</td>
    <td><code>&lt;infinity/&gt;</code></td>
</tr>
<tr><td><code>nan</code>, <code>notanumber</code></td>   
    <td>Mathematical concept "not a number"</td>
    <td><code>&lt;notanumber/&gt;</code></td>
</tr>

<caption class="top-caption">Mathematical symbols defined
in the "Level&nbsp;3" text-string formula syntax.
</caption>
</table>
<p>Again, as mentioned above, whether the string &quot;<code>avogadro</code>&quot; is parsed as an AST node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> is configurable; use the version of the parser function called <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. This Avogadro-related functionality is provided because SBML Level&#160;2 models may not use <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> AST nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the AST to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formula from the given AST as an SBML Level 3 text-string mathematical formula. The caller owns the returned string and is responsible for freeing it when it is no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac4cbd4be2774c80c82b3a678ad71e951">SBML_getDefaultL3ParserSettings()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa38e387dfc8abffaebec3d57625f55d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * SBML_formulaToL3StringWithSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an AST to a string representation of a formula using a syntax basically derived from SBML Level&#160;1, with behavior modifiable with custom settings. </p>
<p>This function behaves identically to <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a>, but its behavior can be modified by two settings in the </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>object, namely:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>ParseUnits: If this is set to 'true' (the default), the function will write out the units of any numerical ASTNodes that have them, producing (for example) "3 mL", "(3/4) m", or "5.5e-10 M". If this is set to 'false', this function will only write out the number itself ("3", "(3/4)", and "5.5e-10", in the previous examples).</li>
</ul>
<ul>
<li>CollapseMinus: If this is set to 'false' (the default), the function will write out explicitly any doubly-nested unary minus ASTNodes, producing (for example) "--x" or even "-----3.1". If this is set to 'true', the function will collapse the nodes before producing the infix, producing "x" and "-3.1" in the previous examples.</li>
</ul>
<p>All other settings will not affect the behavior of this function: the 'parseLog' setting is ignored, and "log10(x)", "ln(x)", and "log(x, y)" are always produced. Nothing in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is used, and whether Avogadro is a csymbol or not is immaterial to the produced infix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the AST to be converted. </td></tr>
    <tr><td class="paramname">settings</td><td>the <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object used to modify behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formula from the given AST as an SBML Level 3 text-string mathematical formula. The caller owns the returned string and is responsible for freeing it when it is no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6432993e301b891cea45b10ed8a0b464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * SBML_formulaToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an AST to a string representation of a formula using a syntax basically derived from SBML Level&#160;1. </p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas produced by <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and read by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> use a simple C-inspired infix notation taken from SBML Level&#160;1. A formula in this text-string form therefore can be handed to a program that understands SBML Level&#160;1 mathematical expressions, or used as part of a formula translation system. The syntax is described in detail in the documentation for <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>. The following are illustrative examples of formulas expressed using this syntax: <pre class="fragment">0.10 * k4^2
</pre> <pre class="fragment">(vm * s1)/(km + s1)
</pre></dd></dl>
<p>Note that this facility is provided as a convenience by libSBML&mdash;the MathML standard does not actually define a "string-form" equivalent to MathML expression trees, so the choice of formula syntax is somewhat arbitrary. The approach taken by libSBML is to use the syntax defined by SBML Level&#160;1 (which in fact used a text-string representation of formulas and not MathML). This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a * b + c</code> is evaluated as <code>(a * b) + c</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a - b + c</code> is evaluated as <code>(a - b) + c</code> because the <code>+</code> and <code>-</code> operators are left-associative.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters, followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a>:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="35">Args</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td><td><em>x</em></td><td>absolute value of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>acos</code></td><td><em>x</em></td><td>arc cosine of <em>x</em> in radians</td><td>-1.0 &le; <em>x</em> &le; 1.0</td><td>0 &le; <em>acos(x)</em> &le; &pi;</td></tr>
<tr><td><code>asin</code></td><td><em>x</em></td><td>arc sine of <em>x</em> in radians</td><td>-1.0 &le; <em>x</em> &le; 1.0</td><td>0 &le; <em>asin(x)</em> &le; &pi;</td></tr>
<tr><td><code>atan</code></td><td><em>x</em></td><td>arc tangent of <em>x</em> in radians</td><td></td><td>0 &le; <em>atan(x)</em> &le; &pi;</td></tr>
<tr><td><code>ceil</code></td><td><em>x</em></td><td>smallest number not less than <em>x</em> whose value is an exact integer</td><td></td><td></td></tr>
<tr><td><code>cos</code></td><td><em>x</em></td><td>cosine of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>exp</code></td><td><em>x</em></td><td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm</td><td></td><td></td></tr>
<tr><td><code>floor</code></td><td><em>x</em></td><td>largest number not greater than <em>x</em> whose value is an exact integer</td><td></td><td></td></tr>
<tr><td><code>log</code></td><td><em>x</em></td><td>natural logarithm of <em>x</em></td><td><em>x</em> &gt; 0</td><td></td></tr>
<tr><td><code>log10</code></td><td><em>x</em></td><td>base 10 logarithm of <em>x</em></td><td><em>x</em> &gt; 0</td><td></td></tr>
<tr><td><code>pow</code></td><td><em>x, y</em></td><td><em>x</em><sup><em> y</em></sup></td><td></td><td></td></tr>
<tr><td><code>sqr</code></td><td><em>x</em></td><td><em>x</em><sup><em>2</em></sup></td><td></td><td></td></tr>
<tr><td><code>sqrt</code></td><td><em>x</em></td><td>&radic;<em>x</em></td><td><em>x</em> &gt; 0</td><td><em>sqrt(x)</em> &ge; 0</td></tr>
<tr><td><code>sin</code></td><td><em>x</em></td><td>sine of <em>x</em></td><td></td><td></td></tr>
<tr><td><code>tan</code></td><td><em>x</em></td><td>tangent of <em>x</em></td><td>x &ne; n*&pi;/2, for odd integer <em>n</em></td><td></td></tr>
<caption class="bottom-caption">The names of mathematical functions defined in the SBML
Level&nbsp;1 Version&nbsp;2 text-string formula syntax.</caption>
</table>

<dl class="section warning"><dt>Warning</dt><dd><span class="warning">There are differences between the symbols used to represent the common mathematical functions and the corresponding MathML token names. This is a potential source of incompatibilities. Note in particular that in this text-string syntax, <code>log(x)</code> represents the natural logarithm, whereas in MathML, the natural logarithm is <code>&lt;ln/&gt;</code>. Application writers are urged to be careful when translating between text forms and MathML forms, especially if they provide a direct text-string input facility to users of their software systems.</span></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the AST to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formula from the given AST as an SBML Level 1 text-string mathematical formula. The caller owns the returned string and is responsible for freeing it when it is no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac4cbd4be2774c80c82b3a678ad71e951">SBML_getDefaultL3ParserSettings()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a9">printMath.c</a>, <a class="el" href="translate_l3_math_8c-example.html#a19">translateL3Math.c</a>, and <a class="el" href="translate_math_8c-example.html#a5">translateMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac4cbd4be2774c80c82b3a678ad71e951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> * SBML_getDefaultL3ParserSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25f79bfaf0dd532cd0a57062fe9523f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * SBML_getLastParseL3Error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last error reported by the "L3" mathematical formula parser. </p>
<p>If the functions <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a>, <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>, or <a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> return <code>NULL</code>, an error is set internally. This function allows callers to retrieve information about the error.</p>
<dl class="section return"><dt>Returns</dt><dd>a string describing the error that occurred. This will contain the input string the parser was trying to parse, the character it had parsed when it encountered the error, and a description of the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac4cbd4be2774c80c82b3a678ad71e951">SBML_getDefaultL3ParserSettings()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="translate_l3_math_8c-example.html#a15">translateL3Math.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae71bc45f2f43f4c3202f7a147e370906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * SBML_parseFormula </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="translate_math_8c-example.html#a1">translateMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8bb78ec9e1237db0e74230cfa5a10598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * SBML_parseL3Formula </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a text string as a mathematical formula and returns an AST representation of it. </p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas read by the function <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> and written by the function <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> uses an expanded version of the syntax read and written by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> and <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>, respectively. The latter two libSBML functions were originally developed to support conversion between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of mathematical formulas used in SBML Level&#160;1. With time, and the use of MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for software developers. To maintain backwards compatibility for libSBML users, the original <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> have been left untouched, and instead, the new functionality is provided in the form of <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> and <a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a>.</dd></dl>
<p>The following lists the main differences in the formula syntax supported by the Level 3 ("L3") versions of the formula parsers and formatters, compared to what is supported by the Level&#160;1-oriented <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> and <a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>:</p>
<ul>
<li>Units may be asociated with bare numbers, using the following syntax: <div style="margin: 10px auto 10px 25px; display: block"> <span class="code" style="background-color: #d0d0ee">number</span> <span class="code" style="background-color: #edd">unit</span> </div> The <span class="code" style="background-color: #d0d0ee">number</span> may be in any form (an integer, real, or rational number), and the <span class="code" style="background-color: #edd">unit</span> must conform to the syntax of an SBML identifier (technically, the type defined as <code>SId</code> in the SBML specifications). The whitespace between <span class="code" style="background-color: #d0d0ee">number</span> and <span class="code" style="background-color: #edd">unit</span> is optional.</li>
</ul>
<ul>
<li>The Boolean function symbols <code>&amp;&amp;</code> (<em>and</em>), <code>||</code> (<em>or</em>), <code>!</code> (<em>not</em>), and <code>!=</code> (<em>not</em> <em>equals</em>) may be used.</li>
</ul>
<ul>
<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and will produce a <code>&lt;piecewise&gt;</code> function in the corresponding MathML output by default, or can produce the MathML function <code>rem</code>, depending on the <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object (see <a class="el" href="class_l3_parser_settings__t.html#ae561a89e47171456f376e158b6e541d1" title="Sets the behavior for handling the &#39;&#39; sumbol in mathematical formulas. ">L3ParserSettings_setParseModuloL3v2()</a> ).</li>
</ul>
<ul>
<li>All inverse trigonometric functions may be defined in the infix either using <code>arc</code> as a prefix or simply <code>a</code>; in other words, both <code>arccsc</code> and <code>acsc</code> are interpreted as the operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions in the simpler SBML Level&#160;1 oriented parser implemented by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> are defined this way as well, but not all.)</li>
</ul>
<ul>
<li>The following expression is parsed as a rational number instead of as a numerical division: <pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre> <b>Spaces are not allowed</b> in this construct; in other words, &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the operator) will be parsed into the MathML <code>&lt;divide&gt;</code> construct rather than a rational number. You can, however, assign units to a rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;. (In the case of division rather than a rational number, units are not interpreted in this way.)</li>
</ul>
<ul>
<li>Various parser and formatter behaviors may be altered through the use of a <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object in conjunction with the functions <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToL3StringWithSettings()</a> The settings available include the following: <ul style="list-style-type: circle">
<li style="margin-bottom: 0.5em">
<p class="startli">The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Unary minus signs can be collapsed or preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input entirely and single unary minuses can be incorporated into the number node, or all minuses can be preserved in the AST node structure.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Parsing of units embedded in the input string can be turned on and off.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string <code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an identifier.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string % can be parsed either as a piecewise function or as the 'rem' function: <code>a % b</code> will either become</p>
<p><code>piecewise(a - b*ceil(a/b), xor((a &lt; 0), (b &lt; 0)), a - b*floor(a/b))</code></p>
<p>or</p>
<p><code>rem(a, b)</code>.</p>
<p>The latter is simpler, but the <code>rem</code> MathML is only allowed as of SBML Level&#160;3 Version&#160;2.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">A <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object may optionally be provided to the parser using the variant function call <a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> or stored in a <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object passed to the variant function <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. When a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is provided, identifiers (values of type <code>SId</code> ) from that model are used in preference to pre-defined MathML definitions for both symbols and functions. More precisely: </p><ul style="list-style-type: square">
<li style="margin-bottom: 0.5em">
<p class="startli"><em>In the case of symbols</em>: the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a>, <a class="el" href="class_compartment__t.html" title=" An SBML compartment, where species are located. ">Compartment_t</a>, <a class="el" href="class_parameter__t.html" title=" An SBML parameter: a named symbol with a value. ">Parameter_t</a>, <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a>, and <a class="el" href="class_species_reference__t.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference_t</a>. For instance, if the parser is given a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> containing a <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<em>In the case of user-defined functions</em>: when a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is provided, <code>SId</code> values of user-defined functions present in the model will be used preferentially over pre-defined MathML functions. For example, if the passed-in <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> contains a <a class="el" href="class_function_definition__t.html" title=" A user-defined function in an SBML model. ">FunctionDefinition_t</a> object with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
</ul>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
An <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> object may optionally be provided to identify SBML Level&#160;3 packages that extend the syntax understood by the formula parser. When the namespaces are provided, the parser will interpret possible additional syntax defined by the libSBML plug-ins implementing the SBML Level&#160;3 packages; for example, it may understand vector/array extensions introduced by the SBML Level&#160;3 <em>Arrays</em> package. </li>
</ul>
</li>
</ul>
<p>These configuration settings cannot be changed directly using the basic parser and formatter functions, but <em>can</em> be changed on a per-call basis by using the alternative functions <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToL3StringWithSettings()</a>.</p>
<p>Neither SBML nor the MathML standard define a "string-form" equivalent to MathML expressions. The approach taken by libSBML is to start with the formula syntax defined by SBML Level&#160;1 (which in fact used a custom text-string representation of formulas, and not MathML), and expand it to include the functionality described above. This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors"
       style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Preced.</th>
     <th align="left">Assoc.</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">8</td><td>left</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">7</td><td>left</td></tr>
<tr><td><code>-, !</code></td><td>negation, Boolean 'not'</td><td>unary</td><td align="center">6</td><td>right</td></tr>
<tr><td><code>*, /, %</code></td><td>multip., div., modulo</td><td>binary</td><td align="center">5</td><td>left</td></tr>
<tr><td><code>+, -</code></td><td>addition and subtraction</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>==, &lt;, &gt;, &lt;=, &gt;=, !=</code></td><td>Boolean comparisons</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>&&, ||</code></td><td>Boolean 'and' and 'or'</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>

<caption class="top-caption">Expression operators and their precedence in the
"Level&nbsp;3" text-string format for mathematical expressions.
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as <code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and <code>||</code> operators are left-associative and have the same precedence.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with additions based on the functions added in SBML Level 2 and Level 3:</p>
<table border="0" width="95%" 
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="75">Argument(s)</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td>   
    <td><em>x</em></td> 
    <td>Absolute value of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acos</code>, <code>arccos</code></td>
    <td><em>x</em></td>
    <td>Arccosine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>acos(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>acosh</code>, <code>arccosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosine of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acot</code>, <code>arccot</code></td>
    <td><em>x</em></td>
    <td>Arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acoth</code>, <code>arccoth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsc</code>, <code>arccsc</code></td>
    <td><em>x</em></td>
    <td>Arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsch</code>, <code>arccsch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asec</code>, <code>arcsec</code></td>
    <td><em>x</em></td>
    <td>Arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asech</code>, <code>arcsech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asin</code>, <code>arcsin</code></td>
    <td><em>x</em></td><td>Arcsine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>asin(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atan</code>, <code>arctan</code></td>
    <td><em>x</em></td>
    <td>Arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td>0 &le; <em>atan(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atanh</code>, <code>arctanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ceil</code>, <code>ceiling</code></td>
    <td><em>x</em></td>
    <td>Smallest number not less than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cos</code></td>
    <td><em>x</em></td>
    <td>Cosine of <em>x</em></td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cot</code></td>
    <td><em>x</em></td>
    <td>Cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>coth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csc</code></td>
    <td><em>x</em></td>
    <td>Cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>delay</code></td>
    <td><em>x, y</em></td>
    <td>The value of <em>x</em> at <em>y</em> time units in the past.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>factorial</code></td>
    <td><em>n</em></td>
    <td>The factorial of <em>n</em>. Factorials are defined by <em>n! = n*(n&ndash;1)* ... * 1</em>.</td>
    <td><em>n</em> must be an integer.</td>
    <td></td>
</tr>
<tr><td><code>exp</code></td>
    <td><em>x</em></td>
    <td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>floor</code></td>
    <td><em>x</em></td>
    <td>The largest number not greater than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ln</code></td>
    <td><em>x</em></td>
    <td>Natural logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x</em></td>
    <td>By default, the base 10 logarithm of <em>x</em>, but can be set to be the natural logarithm of <em>x</em>, or to be an illegal construct.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x, y</em></td>
    <td>The base <em>x</em> logarithm of <em>y</em>.</td>
    <td><em>y</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log10</code></td>
    <td><em>x</em></td>
    <td>Base 10 logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>piecewise</code></td>
    <td><em>x1, y1, [x2, y2,] [...] [z]</em></td>
    <td>A piecewise function: if (<em>y1</em>), <em>x1</em>.  Otherwise, if (<em>y2</em>), <em>x2</em>, etc.  Otherwise, z. </td>
    <td><em>y1, y2, y3 [etc]</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>pow</code>, <code>power</code> </td>
    <td><em>x, y</em></td>
    <td><em>x</em><sup><em> y</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>root</code></td>
    <td><em>b, x</em></td>
    <td>The root base <em>b</em> of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sec</code></td>
    <td><em>x</em></td>
    <td>Secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqr</code></td>
    <td><em>x</em></td>
    <td><em>x</em><sup><em>2</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqrt</code></td>
    <td><em>x</em></td>
    <td>&radic;<em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td><em>sqrt(x)</em> &ge; 0</td>
</tr>
<tr><td><code>sin</code></td>
    <td><em>x</em></td>
    <td>Sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sinh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>tan</code></td>
    <td><em>x</em></td>
    <td>Tangent of <em>x</em>.</td>
    <td>x &ne; n*&pi;/2, for odd integer <em>n</em></td>
    <td></td>
</tr>
<tr><td><code>tanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic tangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>and</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>and(x, y, z...)</em>: returns <code>true</code> if all of its arguments are true.  Note that <code>and</code> is an n-ary function, taking 0 or more arguments, and that <code>and()</code> returns <code>true</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>not</code></td>
    <td><em>x</em></td>
    <td>Boolean <em>not(x)</em></td>
    <td><em>x</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>or</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>or(x, y, z...)</em>: returns <code>true</code> if at least one of its arguments is true.  Note that <code>or</code> is an n-ary function, taking 0 or more arguments, and that <code>or()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>xor</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>xor(x, y, z...)</em>: returns <code>true</code> if an odd number of its arguments is true.  Note that <code>xor</code> is an n-ary function, taking 0 or more arguments, and that <code>xor()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>eq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>eq(x, y, z...)</em>: returns <code>true</code> if all arguments are equal.  Note that <code>eq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>geq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>geq(x, y, z...)</em>: returns <code>true</code> if each argument is greater than or equal to the argument following it.  Note that <code>geq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>gt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>gt(x, y, z...)</em>: returns <code>true</code> if each argument is greater than the argument following it.  Note that <code>gt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>leq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>leq(x, y, z...)</em>: returns <code>true</code> if each argument is less than or equal to the argument following it.  Note that <code>leq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>lt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>lt(x, y, z...)</em>: returns <code>true</code> if each argument is less than the argument following it.  Note that <code>lt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>neq</code></td>
    <td><em>x, y</em></td>
    <td>Boolean <em>x</em> != <em>y</em>: returns <code>true</code> unless x and y are equal.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>plus</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> + <em>y</em> + <em>z</em> + <em>...</em>: The sum of the arguments of the function.  Note that <code>plus</code> is an n-ary function taking 0 or more arguments, and that <code>plus()</code> returns <code>0</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>times</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> * <em>y</em> * <em>z</em> * <em>...</em>: The product of the arguments of the function.  Note that <code>times</code> is an n-ary function taking 0 or more arguments, and that <code>times()</code> returns <code>1</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>minus</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> &ndash; <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>divide</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> / <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>

<caption class="top-caption">Mathematical functions defined
in the "Level&nbsp;3" text-string formula syntax.</caption>

</table>

<p>Parsing of the various MathML functions and constants are all case-insensitive by default: function names such as <code>cos</code>, <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine operator, <code>&lt;cos&gt;</code>. However, <em>when a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object is used</em> in conjunction with either <a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> or <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>, any identifiers found in that model will be parsed in a case-<em>sensitive</em> way. For example, if a model contains a <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a> having the identifier <code>Pi</code>, the parser will parse &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi &lt;/ci&gt;</code>&quot; but will continue to parse the symbols &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as &quot;<code>&lt;pi&gt;</code>&quot;.</p>
<p>As mentioned above, the manner in which the "L3" versions of the formula parser and formatter interpret the function &quot;<code>log</code>&quot; can be changed. To do so, callers should use the function <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and pass it an appropriate <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> object. By default, unlike the SBML Level&#160;1 parser implemented by <a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a>, the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10 logarithm, and <em>not</em> as the natural logarithm. However, you can change the interpretation to be base-10 log, natural log, or as an error; since the name "log" by itself is ambiguous, you require that the parser uses <code>log10</code> or <code>ln</code> instead, which are more clear. Please refer to <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>.</p>
<p>In addition, the following symbols will be translated to their MathML equivalents, if no symbol with the same <code>SId</code> identifier string exists in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object provided:</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="250">Meaning</th>
     <th align="left">MathML</th>
 </tr>
<tr><td><code>true</code></td>   
    <td>Boolean value <code>true</code></td>
    <td><code>&lt;true/&gt;</code></td>
</tr>
<tr><td><code>false</code></td>   
    <td>Boolean value <code>false</code></td>
    <td><code>&lt;false/&gt;</code></td>
</tr>
<tr><td><code>pi</code></td>   
    <td>Mathematical constant pi</td>
    <td><code>&lt;pi/&gt;</code></td>
</tr>
<tr><td><code>avogadro</code></td>   
    <td>Value of Avogadro's constant stipulated by SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/avogadro"&gt; avogadro &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>time</code></td>   
    <td>Simulation time as defined in SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/time"&gt; time &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>inf</code>, <code>infinity</code></td>   
    <td>Mathematical constant "infinity"</td>
    <td><code>&lt;infinity/&gt;</code></td>
</tr>
<tr><td><code>nan</code>, <code>notanumber</code></td>   
    <td>Mathematical concept "not a number"</td>
    <td><code>&lt;notanumber/&gt;</code></td>
</tr>

<caption class="top-caption">Mathematical symbols defined
in the "Level&nbsp;3" text-string formula syntax.
</caption>
</table>
<p>Again, as mentioned above, whether the string &quot;<code>avogadro</code>&quot; is parsed as an AST node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> is configurable; use the version of the parser function called <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. This Avogadro-related functionality is provided because SBML Level&#160;2 models may not use <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> AST nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the text-string formula expression to be parsed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using <a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#aa38e387dfc8abffaebec3d57625f55d3" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToL3StringWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#afac029dddfabae36ca83d8091739cd88" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1...">SBML_formulaToL3String()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a6432993e301b891cea45b10ed8a0b464" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> </dd>
<dd>
<a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ac4cbd4be2774c80c82b3a678ad71e951">SBML_getDefaultL3ParserSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>We urge developers to keep in mind that the text-string formula syntax is specific to libSBML. <em>Neither MathML nor SBML define a text-string format for mathematical formulas.</em> LibSBML's particular syntax should not be considered to be a canonical or standard general-purpose mathematical expression syntax. LibSBML provides methods for parsing and transforming text-string math formulas back and forth from AST structures for the convenience of calling applications, but it is important to keep the system's limitations in mind. </dd></dl>

</div>
</div>
<a class="anchor" id="a80016dfe4a4038c9a497ebc048132e28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * SBML_parseL3FormulaWithModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_model__t.html">Model_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a text string as a mathematical formula using a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> to resolve symbols, and returns an AST representation of the result. </p>
<p>This is identical to <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a>, except that this function uses the given model in the argument <code>model</code> to check against identifiers that appear in the <code>formula</code>. For more information about the parser, please see the definition of <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> and the function <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the mathematical formula expression to be parsed.</td></tr>
    <tr><td class="paramname">model</td><td>the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object to use for checking identifiers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using <a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a> </dd>
<dd>
<a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc22ca3cfa5450713eb88a6aa824ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * SBML_parseL3FormulaWithSettings </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_l3_parser_settings__t.html">L3ParserSettings_t</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a text string as a mathematical formula using specific parser settings and returns an AST representation of the result. </p>
<p>This is identical to <a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a>, except that this function uses the parser settings given in the argument <code>settings</code>. The settings override the default parsing behavior. The following parsing behaviors can be configured:</p>
<ul>
<li>A <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object may optionally be provided to use identifiers (values of type <code>SId</code>) from the model in preference to pre-defined MathML symbols More precisely, the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a>, <a class="el" href="class_compartment__t.html" title=" An SBML compartment, where species are located. ">Compartment_t</a>, <a class="el" href="class_parameter__t.html" title=" An SBML parameter: a named symbol with a value. ">Parameter_t</a>, <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a>, and <a class="el" href="class_species_reference__t.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference_t</a>. For instance, if the parser is given a <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> containing a <a class="el" href="class_species__t.html" title=" An SBML species – a pool of entities. ">Species_t</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced by the parser will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>. Another example, if the passed-in <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> contains a <a class="el" href="class_function_definition__t.html" title=" A user-defined function in an SBML model. ">FunctionDefinition_t</a> with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
<li>The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired. </li>
<li>Unary minus signs can be either collapsed or preserved; that is, the parser can either (1) remove sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) from the input and incorporate single unary minuses into the number node, or (2) preserve all minuses in the AST node structure, turning them into <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> objects of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>. </li>
<li>The character sequence &quot;<code>number id</code>&quot; can be interpreted as a numerical value <code>number</code> followed by units of measurement indicated by <code>id</code>, or it can be treated as a syntax error. (In Level&#160;3, MathML <code>&lt;cn&gt;</code> elements can have an attribute named <code>units</code> placed in the SBML namespace, which can be used to indicate the units to be associated with the number. The text-string infix formula parser allows units to be placed after raw numbers; they are interpreted as unit identifiers for units defined by the SBML specification or in the containing <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a> object.) </li>
<li>The symbol <code>avogadro</code> can be parsed either as a MathML <em>csymbol</em> or as a identifier. More specifically, &quot;<code>avogadro</code>&quot; can be treated as an <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> or of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a>. </li>
<li>Strings that match built-in functions and constants can either be parsed as a match regardless of capitalization, or may be required to be all-lower-case to be considered a match. </li>
<li>LibSBML plug-ins implementing support for SBML Level&#160;3 packages may introduce extensions to the syntax understood by the parser. The precise nature of the extensions will be documented by the individual package plug-ins. An example of a possible extension is a notation for vectors and arrays, introduced by the SBML Level&#160;3 <em>Arrays</em> package.</li>
</ul>
<p>For more details about the parser, please see the definition of <a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> and <a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the mathematical formula expression to be parsed.</td></tr>
    <tr><td class="paramname">settings</td><td>the settings to be used for this parser invocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using <a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node__t.html#a8bb78ec9e1237db0e74230cfa5a10598" title="Parses a text string as a mathematical formula and returns an AST representation of it...">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a1cc22ca3cfa5450713eb88a6aa824ad2" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a80016dfe4a4038c9a497ebc048132e28" title="Parses a text string as a mathematical formula using a Model_t to resolve symbols, and returns an AST representation of the result. ">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#ae71bc45f2f43f4c3202f7a147e370906">SBML_parseFormula()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node__t.html#a25f79bfaf0dd532cd0a57062fe9523f4" title="Returns the last error reported by the &quot;L3&quot; mathematical formula parser. ">SBML_getLastParseL3Error()</a> </dd>
<dd>
<a class="el" href="class_l3_parser_settings__t.html" title=" Controls the behavior of the Level 3 formula parser. ">L3ParserSettings_t</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="translate_l3_math_8c-example.html#a14">translateL3Math.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a988e70c7afa39b921d879cdab7a426b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * writeMathMLToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a> (and its children) to a string as MathML, and returns the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the root of an AST to write out to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the written-out MathML representation of the given AST.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string is owned by the caller and should be freed (with free()) when no longer needed. <code>NULL</code> is returned if the given argument is <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af42b80199364ed95883587997eddcea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * writeMathMLToString </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="translate_l3_math_8c-example.html#a16">translateL3Math.c</a>, and <a class="el" href="translate_math_8c-example.html#a2">translateMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac70fefd98ddedee8b0214220018608c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * writeMathMLWithNamespaceToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given AST node (and its children) to a string as MathML, and returns the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the root of an AST to write out to the stream. </td></tr>
    <tr><td class="paramname">sbmlns</td><td>the SBML namespace to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the written-out MathML representation of the given AST.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string is owned by the caller and should be freed (with free()) when no longer needed. <code>NULL</code> is returned if the given argument is <code>NULL</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
