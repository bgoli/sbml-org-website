/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sbml.libsbml;

/** 
 * <span class="pkg-marker pkg-color-comp"><a href="group__comp.html">comp</a></span>
 Extension of {@link SBase}.
 <p>
 * The {@link CompSBasePlugin} class inherits from the {@link SBasePlugin} class, and
 * codifies the extensions to the {@link SBase} class defined in the <a href='../../../extensions-summary.html#comp'>Hierarchical Model Composition</a>
 * (&ldquo;comp&rdquo;) package.  This extension allows the modeler to define
 * one or more submodel elements which the parent {@link SBase} object replaces,
 * and/or a single submodel element which replaces the parent {@link SBase} object.
<p>
 * This is accomplished through the addition of an optional {@link ListOfReplacedElements}
 * child, which may contain one or more {@link ReplacedElement} objects, each of which 
 * references a submodel object to be replaced by the containing {@link SBase} object, 
 * and through the addition of a single optional {@link ReplacedBy} child, which 
 * references a submodel object which is to replace the containing {@link SBase} object.
<p>
 * If a single {@link SBase} element both contains a {@link ListOfReplacedElements} and has a {@link ReplacedBy}
 * child, it and all the referenced {@link ReplacedElement} objects are to be replaced
 * by the object referenced by the {@link ReplacedBy} element.
 <p>
 * @see ReplacedElement
 * @see ReplacedBy
 */

public class CompSBasePlugin extends SBasePlugin {
   private long swigCPtr;

   protected CompSBasePlugin(long cPtr, boolean cMemoryOwn)
   {
     super(libsbmlJNI.CompSBasePlugin_SWIGUpcast(cPtr), cMemoryOwn);
     swigCPtr = cPtr;
   }

   protected static long getCPtr(CompSBasePlugin obj)
   {
     return (obj == null) ? 0 : obj.swigCPtr;
   }

   protected static long getCPtrAndDisown (CompSBasePlugin obj)
   {
     long ptr = 0;

     if (obj != null)
     {
       ptr             = obj.swigCPtr;
       obj.swigCMemOwn = false;
     }

     return ptr;
   }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libsbmlJNI.delete_CompSBasePlugin(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  
/**
   * Creates a new {@link CompSBasePlugin} object using the given parameters.
   <p>
   * <p>
 * In the XML representation of an SBML document, XML namespaces are used to
 * identify the origin of each XML construct used.  XML namespaces are
 * identified by their unique resource identifiers (URIs).  The core SBML
 * specifications stipulate the namespaces that must be used for core SBML
 * constructs; for example, all XML elements that belong to SBML Level&nbsp;3
 * Version&nbsp;1 Core must be placed in the XML namespace identified by the URI
 * <code>'http://www.sbml.org/sbml/level3/version1/core'</code>.  Individual
 * SBML Level&nbsp;3 packages define their own XML namespaces; for example,
 * all elements belonging to the SBML Level&nbsp;3 Layout Version&nbsp;1
 * package must be placed in the XML namespace
 * <code>'http://www.sbml.org/sbml/level3/version1/layout/version1/'</code>.
   <p>
   * <p>
 * The {@link SBMLNamespaces} object encapsulates SBML Level/Version/namespaces
 * information.  It is used to communicate the SBML Level, Version, and (in
 * Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
 * common approach to using libSBML's {@link SBMLNamespaces} facilities is to create an
 * {@link SBMLNamespaces} object somewhere in a program once, then hand that object
 * as needed to object constructors that accept {@link SBMLNamespaces} as arguments.
   <p>
   * @param uri the URI of the SBML Level&nbsp;3 package implemented by
   * this libSBML package extension.
   <p>
   * @param prefix the XML namespace prefix being used for the package.
   <p>
   * @param compns the namespaces object for the package.
   */ public
 CompSBasePlugin(String uri, String prefix, CompPkgNamespaces compns) {
    this(libsbmlJNI.new_CompSBasePlugin__SWIG_0(uri, prefix, CompPkgNamespaces.getCPtr(compns), compns), true);
  }

  
/**
   * Copy constructor. Creates a copy of this {@link CompSBasePlugin} object.
   <p>
   * @param orig the instance to copy.
   */ public
 CompSBasePlugin(CompSBasePlugin orig) {
    this(libsbmlJNI.new_CompSBasePlugin__SWIG_1(CompSBasePlugin.getCPtr(orig), orig), true);
  }

  
/**
   * Creates and returns a deep copy of this {@link CompSBasePlugin} object.
   <p>
   * @return a (deep) copy of this {@link CompSBasePlugin} object.
   */ public
 SBasePlugin cloneObject() {
    long cPtr = libsbmlJNI.CompSBasePlugin_cloneObject(swigCPtr, this);
    return (cPtr == 0) ? null : new CompSBasePlugin(cPtr, true);
  }

  
/** * @internal */ public
 SBase createObject(XMLInputStream stream) {
  return libsbml.DowncastSBase(libsbmlJNI.CompSBasePlugin_createObject(swigCPtr, this, XMLInputStream.getCPtr(stream), stream), false);
}

  
/**
   * Returns the first child element found that has the given <code>id</code> in the
   * model-wide SId namespace, or <code>null</code> if no such object is found.
   <p>
   * @param id string representing the id of the object to find.
   <p>
   * @return a pointer to the {@link SBase} element with the given <code>id</code>.
   */ public
 SBase getElementBySId(String id) {
  return libsbml.DowncastSBase(libsbmlJNI.CompSBasePlugin_getElementBySId(swigCPtr, this, id), false);
}

  
/**
   * Returns the first child element it can find with the given <code>metaid</code>, or
   * itself if it has the given <code>metaid</code>, or <code>null</code> if no such object is
   * found.
   <p>
   * @param metaid string representing the metaid of the object to find.
   <p>
   * @return a pointer to the {@link SBase} element with the given <code>metaid</code>.
   */ public
 SBase getElementByMetaId(String metaid) {
  return libsbml.DowncastSBase(libsbmlJNI.CompSBasePlugin_getElementByMetaId(swigCPtr, this, metaid), false);
}

  
/**
   * Returns the {@link ListOf} object that holds all replacedElements.
   <p>
   * @return the {@link ListOf} object that holds all replacedElements.
   */ public
 ListOfReplacedElements getListOfReplacedElements() {
    long cPtr = libsbmlJNI.CompSBasePlugin_getListOfReplacedElements__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new ListOfReplacedElements(cPtr, false);
  }

  
/**
   * Returns the {@link ReplacedElement} with the given index.
   <p>
   * @param n the index number of the {@link ReplacedElement} to get.
   <p>
   * @return the nth {@link ReplacedElement} in the {@link ListOfReplacedElements}.  If the
   * index is invalid, <code>null</code> is returned.
   */ public
 ReplacedElement getReplacedElement(long n) {
    long cPtr = libsbmlJNI.CompSBasePlugin_getReplacedElement__SWIG_0(swigCPtr, this, n);
    return (cPtr == 0) ? null : new ReplacedElement(cPtr, false);
  }

  
/**
   * Adds a copy of the given {@link ReplacedElement} object to the list of ReplacedElements.
   <p>
   * @param replacedElement the {@link ReplacedElement} object to be added to the
   * list of ReplacedElements.  Fails if the added {@link ReplacedElement} is <code>null</code>,
   * does not match the level/version/package of the parent object, or cannot
   * be added to the list of replaced elements.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT}
   * <li> {@link libsbmlConstants#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH}
   * </ul>
   */ public
 int addReplacedElement(ReplacedElement replacedElement) {
    return libsbmlJNI.CompSBasePlugin_addReplacedElement(swigCPtr, this, ReplacedElement.getCPtr(replacedElement), replacedElement);
  }

  
/**
   * Returns the number of ReplacedElements for this {@link CompSBasePlugin}.
   <p>
   * @return the number of ReplacedElements for this {@link CompSBasePlugin}.
   */ public
 long getNumReplacedElements() {
    return libsbmlJNI.CompSBasePlugin_getNumReplacedElements(swigCPtr, this);
  }

  
/**
   * Remove all ReplacedElements, if any exist.
   */ public
 void clearReplacedElements() {
    libsbmlJNI.CompSBasePlugin_clearReplacedElements(swigCPtr, this);
  }

  
/**
   * Creates a {@link ReplacedElement} object, adds it to the end of the
   * {@link ReplacedElement} objects list and returns a pointer to the newly
   * created object.
   <p>
   * @return a newly created {@link ReplacedElement} object.
   */ public
 ReplacedElement createReplacedElement() {
    long cPtr = libsbmlJNI.CompSBasePlugin_createReplacedElement(swigCPtr, this);
    return (cPtr == 0) ? null : new ReplacedElement(cPtr, false);
  }

  
/**
   * Removes the {@link ReplacedElement} with the given index.
   <p>
   * A pointer to the {@link ReplacedElement} that was removed is returned.
   * If no {@link ReplacedElement} has been removed, <code>null</code> is returned.
   <p>
   * @param index the index of the {@link ReplacedElement} object to remove.
   <p>
   * @return the {@link ReplacedElement} object removed.  As mentioned above, 
   * the caller owns the returned object. <code>null</code> is returned if 
   * the given index is out of range.
   */ public
 ReplacedElement removeReplacedElement(long index) {
    long cPtr = libsbmlJNI.CompSBasePlugin_removeReplacedElement(swigCPtr, this, index);
    return (cPtr == 0) ? null : new ReplacedElement(cPtr, false);
  }

  
/**
   * Get the child {@link ReplacedBy} of this {@link SBase}.
   <p>
   * @return the  {@link ReplacedBy} child of this {@link SBase}.
   */ public
 ReplacedBy getReplacedBy() {
    long cPtr = libsbmlJNI.CompSBasePlugin_getReplacedBy__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new ReplacedBy(cPtr, false);
  }

  
/**
   * Predicate for testing whether the {@link ReplacedBy} for this {@link SBase} is set.
   <p>
   * @return <code>true</code> if the {@link ReplacedBy} of this {@link SBase} is set, <code>false</code>
   * otherwise.
   */ public
 boolean isSetReplacedBy() {
    return libsbmlJNI.CompSBasePlugin_isSetReplacedBy(swigCPtr, this);
  }

  
/**
   * Sets the {@link ReplacedBy} definition of this {@link SBase} to a copy of the given
   * {@link ReplacedBy} object instance.
   <p>
   * This method fails if the added {@link ReplacedBy} does not match the
   * level/version/package of the parent object or if the added {@link ReplacedBy}
   * cannot be copied.
   <p>
   * @param replacedBy the {@link ReplacedBy} object instance to use.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * <li> {@link libsbmlConstants#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH}
   * </ul>
   */ public
 int setReplacedBy(ReplacedBy replacedBy) {
    return libsbmlJNI.CompSBasePlugin_setReplacedBy(swigCPtr, this, ReplacedBy.getCPtr(replacedBy), replacedBy);
  }

  
/**
   * Creates a new, empty {@link ReplacedBy}, adds it to this {@link CompSBasePlugin} and 
   * returns the created {@link ReplacedBy}.
   <p>
   * @return the newly created {@link ReplacedBy} object instance.
   */ public
 ReplacedBy createReplacedBy() {
    long cPtr = libsbmlJNI.CompSBasePlugin_createReplacedBy(swigCPtr, this);
    return (cPtr == 0) ? null : new ReplacedBy(cPtr, false);
  }

  
/**
   * Unsets the child {@link ReplacedBy} of this {@link SBase}.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int unsetReplacedBy() {
    return libsbmlJNI.CompSBasePlugin_unsetReplacedBy(swigCPtr, this);
  }

  
/**
   * Helper to log a common type of error.
   */ public
 void logInvalidId(String attribute, String wrongattribute) {
    libsbmlJNI.CompSBasePlugin_logInvalidId(swigCPtr, this, attribute, wrongattribute);
  }

  
/** * @internal */ public
 void connectToChild() {
    libsbmlJNI.CompSBasePlugin_connectToChild(swigCPtr, this);
  }

  
/** * @internal */ public
 void connectToParent(SBase parent) {
    libsbmlJNI.CompSBasePlugin_connectToParent(swigCPtr, this, SBase.getCPtr(parent), parent);
  }

  
/** * @internal */ public
 void enablePackageInternal(String pkgURI, String pkgPrefix, boolean flag) {
    libsbmlJNI.CompSBasePlugin_enablePackageInternal(swigCPtr, this, pkgURI, pkgPrefix, flag);
  }

}
