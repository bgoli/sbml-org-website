/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sbml.libsbml;

/** 
 * <span class="pkg-marker pkg-color-comp"><a href="group__comp.html">comp</a></span>
 Extension of {@link Model}.
 <p>
 * The {@link CompModelPlugin} class inherits from the SBMLSBasePlugin class, and
 * codifies the extensions to the {@link Model} class defined in the SBML
 * Level&nbsp;3 <a href='../../../extensions-summary.html#comp'>Hierarchical Model Composition</a> (&ldquo;comp&rdquo;) package.  This extension
 * allows a {@link Model} to define Submodels (other Models that are instantiated as
 * new parts of the parent {@link Model}), and Ports, a defined interface for
 * including the given {@link Model} as a {@link Submodel} of a different {@link Model}.
 <p>
 * Submodels are stored in an optional child {@link ListOfSubmodels} object, which, 
 * if present, must contain one or more {@link Submodel} objects.  All of the Submodels
 * present in the {@link ListOfSubmodels} are defined to be instantiated in the
 * 'complete' {@link Model}.
 <p>
 * Ports are stored in an optional child {@link ListOfPorts} object, which, 
 * if present, must contain one or more {@link Port} objects.  All of the Ports
 * present in the {@link ListOfPorts} collectively define the 'port interface'
 * of the {@link Model}.
 */

public class CompModelPlugin extends CompSBasePlugin {
   private long swigCPtr;

   protected CompModelPlugin(long cPtr, boolean cMemoryOwn)
   {
     super(libsbmlJNI.CompModelPlugin_SWIGUpcast(cPtr), cMemoryOwn);
     swigCPtr = cPtr;
   }

   protected static long getCPtr(CompModelPlugin obj)
   {
     return (obj == null) ? 0 : obj.swigCPtr;
   }

   protected static long getCPtrAndDisown (CompModelPlugin obj)
   {
     long ptr = 0;

     if (obj != null)
     {
       ptr             = obj.swigCPtr;
       obj.swigCMemOwn = false;
     }

     return ptr;
   }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libsbmlJNI.delete_CompModelPlugin(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  
/**
   * Creates a new {@link CompModelPlugin} object using the given parameters.
   <p>
   * <p>
 * In the XML representation of an SBML document, XML namespaces are used to
 * identify the origin of each XML construct used.  XML namespaces are
 * identified by their unique resource identifiers (URIs).  The core SBML
 * specifications stipulate the namespaces that must be used for core SBML
 * constructs; for example, all XML elements that belong to SBML Level&nbsp;3
 * Version&nbsp;1 Core must be placed in the XML namespace identified by the URI
 * <code>'http://www.sbml.org/sbml/level3/version1/core'</code>.  Individual
 * SBML Level&nbsp;3 packages define their own XML namespaces; for example,
 * all elements belonging to the SBML Level&nbsp;3 Layout Version&nbsp;1
 * package must be placed in the XML namespace
 * <code>'http://www.sbml.org/sbml/level3/version1/layout/version1/'</code>.
   <p>
   * <p>
 * The {@link SBMLNamespaces} object encapsulates SBML Level/Version/namespaces
 * information.  It is used to communicate the SBML Level, Version, and (in
 * Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
 * common approach to using libSBML's {@link SBMLNamespaces} facilities is to create an
 * {@link SBMLNamespaces} object somewhere in a program once, then hand that object
 * as needed to object constructors that accept {@link SBMLNamespaces} as arguments.
   <p>
   * @param uri the URI of the SBML Level&nbsp;3 package implemented by
   * this libSBML package extension.
   <p>
   * @param prefix the XML namespace prefix being used for the package.
   <p>
   * @param compns the namespaces object for the package.
   */ public
 CompModelPlugin(String uri, String prefix, CompPkgNamespaces compns) {
    this(libsbmlJNI.new_CompModelPlugin__SWIG_0(uri, prefix, CompPkgNamespaces.getCPtr(compns), compns), true);
  }

  
/**
   * Copy constructor. Creates a copy of this {@link CompModelPlugin} object.
   <p>
   * @param orig the instance to copy.
   */ public
 CompModelPlugin(CompModelPlugin orig) {
    this(libsbmlJNI.new_CompModelPlugin__SWIG_1(CompModelPlugin.getCPtr(orig), orig), true);
  }

  
/**
   * Creates and returns a deep copy of this {@link CompModelPlugin} object.
   <p>
   * @return a (deep) copy of this {@link CompModelPlugin} object.
   */ public
 SBasePlugin cloneObject() {
    long cPtr = libsbmlJNI.CompModelPlugin_cloneObject(swigCPtr, this);
    return (cPtr == 0) ? null : new CompModelPlugin(cPtr, true);
  }

  
/** * @internal */ public
 SBase createObject(XMLInputStream stream) {
  return libsbml.DowncastSBase(libsbmlJNI.CompModelPlugin_createObject(swigCPtr, this, XMLInputStream.getCPtr(stream), stream), false);
}

  
/**
   * Returns the first child element found that has the given <code>id</code> in the
   * model-wide SId namespace, or <code>null</code> if no such object is found.
   <p>
   * @param id a string representing the id of the object to find.
   <p>
   * @return a pointer to the {@link SBase} element with the given <code>id</code>.
   */ public
 SBase getElementBySId(String id) {
  return libsbml.DowncastSBase(libsbmlJNI.CompModelPlugin_getElementBySId(swigCPtr, this, id), false);
}

  
/**
   * Returns the first child element it can find with the given meta
   * identifier, or itself if it has the given <code>metaid</code>, or <code>null</code> if no
   * such object is found.
   <p>
   * @param metaid a string representing the metaid of the object to find.
   <p>
   * @return a pointer to the {@link SBase} element with the given <code>metaid</code>.
   */ public
 SBase getElementByMetaId(String metaid) {
  return libsbml.DowncastSBase(libsbmlJNI.CompModelPlugin_getElementByMetaId(swigCPtr, this, metaid), false);
}

  
/**
  * Returns the {@link ListOfSubmodels} from this {@link CompModelPlugin}.
  <p>
  * @return the {@link ListOfSubmodels} from this {@link CompModelPlugin}.
  <p>
  * <p>
 * @note
 * The pointer that is returned by this function is not owned by the caller,
 * but may be queried and modified.  Any changes made will be reflected in any
 * resulting SBML document containing the pointer's parent.
  <p>
  * @see #addSubmodel(Submodel object)
  * @see #createSubmodel()
  * @see #getSubmodel(String sid)
  * @see #getSubmodel(long n)
  * @see #getNumSubmodels()
  * @see #removeSubmodel(long n)
  */ public
 ListOfSubmodels getListOfSubmodels() {
    long cPtr = libsbmlJNI.CompModelPlugin_getListOfSubmodels__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new ListOfSubmodels(cPtr, false);
  }

  
/**
   * Returns the submodel with the given index.
   * If the index is invalid, <code>null</code> is returned.
   <p>
   * @param n the index number of the {@link Submodel} to get.
   <p>
   * @return the nth {@link Submodel} in the {@link ListOfSubmodels} or <code>null</code> if 
   * no such object exists.
   */ public
 Submodel getSubmodel(long n) {
    long cPtr = libsbmlJNI.CompModelPlugin_getSubmodel__SWIG_0(swigCPtr, this, n);
    return (cPtr == 0) ? null : new Submodel(cPtr, false);
  }

  
/**
   * Returns the submodel with the given identifier.
   <p>
   * @param id the identifier of the {@link Submodel} to get.
   <p>
   * @return the {@link Submodel} in the {@link ListOfSubmodels} with the given identifier.
   * If no such submodel with identifier <code>id</code> exists, <code>null</code> is returned.
   */ public
 Submodel getSubmodel(String id) {
    long cPtr = libsbmlJNI.CompModelPlugin_getSubmodel__SWIG_2(swigCPtr, this, id);
    return (cPtr == 0) ? null : new Submodel(cPtr, false);
  }

  
/**
   * Adds a copy of the given {@link Submodel} object to the list of submodels.
   <p>
   * Fails if the added submodel is <code>null</code>, does not match the
   * level/version/package of the parent object, or cannot be added to the
   * list of submodels.
   <p>
   * @param submodel the {@link Submodel} object to be added to the list of
   * submodels.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT}
   * <li> {@link libsbmlConstants#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH}
   * </ul>
   */ public
 int addSubmodel(Submodel submodel) {
    return libsbmlJNI.CompModelPlugin_addSubmodel(swigCPtr, this, Submodel.getCPtr(submodel), submodel);
  }

  
/**
   * Returns the number of submodels for this {@link CompModelPlugin}.
   <p>
   * @return the number of submodels for this {@link CompModelPlugin}.
   */ public
 long getNumSubmodels() {
    return libsbmlJNI.CompModelPlugin_getNumSubmodels(swigCPtr, this);
  }

  
/**
   * Creates a {@link Submodel} object, adds it to the end of the
   * submodel objects list and returns a pointer to the newly
   * created object.
   <p>
   * @return a newly created {@link Submodel} object.
   */ public
 Submodel createSubmodel() {
    long cPtr = libsbmlJNI.CompModelPlugin_createSubmodel(swigCPtr, this);
    return (cPtr == 0) ? null : new Submodel(cPtr, false);
  }

  
/**
   * Removes the submodel with the given index.
   * A pointer to the submodel that was removed is returned.
   * The caller owns the returned item and is responsible for deleting it.
   <p>
   * @param index the index of the {@link Submodel} object to remove.
   <p>
   * @return the {@link Submodel} object removed.  As mentioned above, the caller
   * owns the returned object. <code>null</code> is returned if the given <code>index</code> is
   * out of range and no submodel has been removed, <code>null</code> is returned.
   */ public
 Submodel removeSubmodel(long index) {
    long cPtr = libsbmlJNI.CompModelPlugin_removeSubmodel(swigCPtr, this, index);
    return (cPtr == 0) ? null : new Submodel(cPtr, false);
  }

  
/**
  * Returns the {@link ListOfPorts} from this {@link CompModelPlugin}.
  <p>
  * @return the {@link ListOfPorts} from this {@link CompModelPlugin}.
  <p>
  * <p>
 * @note
 * The pointer that is returned by this function is not owned by the caller,
 * but may be queried and modified.  Any changes made will be reflected in any
 * resulting SBML document containing the pointer's parent.
  <p>
  * @see #addPort(Port object)
  * @see #createPort()
  * @see #getPort(String sid)
  * @see #getPort(long n)
  * @see #getNumPorts()
  * @see #removePort(long n)
  */ public
 ListOfPorts getListOfPorts() {
    long cPtr = libsbmlJNI.CompModelPlugin_getListOfPorts__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new ListOfPorts(cPtr, false);
  }

  
/**
   * Returns the port with the given index.
   <p>
   * @param n the index number of the {@link Port} to get.
   <p>
   * @return the nth {@link Port} in the {@link ListOfPorts}.  If the index <code>n</code> is invalid,
   * <code>null</code> is returned.
   */ public
 Port getPort(long n) {
    long cPtr = libsbmlJNI.CompModelPlugin_getPort__SWIG_0(swigCPtr, this, n);
    return (cPtr == 0) ? null : new Port(cPtr, false);
  }

  
/**
   * Returns the port with the given identifier.
   <p>
   * @param id the id of the {@link Port} to get.
   <p>
   * @return the {@link Port} in the {@link ListOfPorts} with the given identifier.  If the
   * identifier is invalid, <code>null</code> is returned.
   */ public
 Port getPort(String id) {
    long cPtr = libsbmlJNI.CompModelPlugin_getPort__SWIG_2(swigCPtr, this, id);
    return (cPtr == 0) ? null : new Port(cPtr, false);
  }

  
/**
   * Adds a copy of the given {@link Port} object to the list of ports.
   <p>
   * @param port the {@link Port} object to be added to the list of ports.  Fails if
   * the added port is <code>null</code>, does not match the level/version/package of the
   * parent object, or cannot be added to the list of ports.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT}
   * <li> {@link libsbmlConstants#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH}
   * <li> {@link libsbmlConstants#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH}
   * </ul>
   */ public
 int addPort(Port port) {
    return libsbmlJNI.CompModelPlugin_addPort(swigCPtr, this, Port.getCPtr(port), port);
  }

  
/**
   * Returns the number of ports for this {@link CompModelPlugin}.
   <p>
   * @return the number of ports for this {@link CompModelPlugin}.
   */ public
 long getNumPorts() {
    return libsbmlJNI.CompModelPlugin_getNumPorts(swigCPtr, this);
  }

  
/**
   * Creates a {@link Port} object, adds it to the end of the
   * port objects list and returns a pointer to the newly
   * created object.
   <p>
   * @return a newly created {@link Port} object.
   */ public
 Port createPort() {
    long cPtr = libsbmlJNI.CompModelPlugin_createPort(swigCPtr, this);
    return (cPtr == 0) ? null : new Port(cPtr, false);
  }

  
/**
   * Removes the port with the given index.
   * The caller owns the returned item and is responsible for deleting it.
   <p>
   * @param index the index of the {@link Port} object to remove.
   <p>
   * @return the {@link Port} object removed.  As mentioned above, 
   * the caller owns the returned object. <code>null</code> is returned if 
   * the given index is out of range.
   */ public
 Port removePort(long index) {
    long cPtr = libsbmlJNI.CompModelPlugin_removePort(swigCPtr, this, index);
    return (cPtr == 0) ? null : new Port(cPtr, false);
  }

  
/**
   * Set the string used as the divider between names when renaming and
   * flattening models.
   <p>
   * The divider string consists of two underscore characters
   * (&quot;<code>__</code>&quot;) by default.  This method will fail if called
   * with an empty <code>divider</code>, or a <code>divider</code> that cannot be used internally as part
   * of a valid SBML SId.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int setDivider(String divider) {
    return libsbmlJNI.CompModelPlugin_setDivider(swigCPtr, this, divider);
  }

  
/**
   * Get the string used as the divider between names when renaming and
   * flattening models.
   <p>
   * The divider string consists of two underscore characters
   * (&quot;<code>__</code>&quot;) by default, and can be overridden
   * with the setDivider() function.
   <p>
   * @return the divider that will be used by any call to flattenModel().
   <p>
   * @see #setDivider(String divider)
   */ public
 String getDivider() {
    return libsbmlJNI.CompModelPlugin_getDivider(swigCPtr, this);
  }

  
/** * @internal */ public
 void connectToChild() {
    libsbmlJNI.CompModelPlugin_connectToChild(swigCPtr, this);
  }

  
/** * @internal */ public
 void connectToParent(SBase parent) {
    libsbmlJNI.CompModelPlugin_connectToParent(swigCPtr, this, SBase.getCPtr(parent), parent);
  }

  
/** * @internal */ public
 void enablePackageInternal(String pkgURI, String pkgPrefix, boolean flag) {
    libsbmlJNI.CompModelPlugin_enablePackageInternal(swigCPtr, this, pkgURI, pkgPrefix, flag);
  }

  
/**
   * Sets the custom transformer that is to be used, instead of the standard
   * prefixing with the given divider. This makes it possible to finely control
   * how elements are altered. 
   <p>
   * If not set, only ids and meta ids will be prefixed. 
   <p>
   * NOTE: the model plugin only holds the pointer to the element it does not 
   *       take ownership of it. Thus the calling program is responsible of 
   *       freeing the transformer when no longer needed (i.e after the 
   *       SBML document has been deleted)
   <p>
   * @param transformer the prefix transformer to use.
   */ public
 void setTransformer(SWIGTYPE_p_PrefixTransformer transformer) {
    libsbmlJNI.CompModelPlugin_setTransformer(swigCPtr, this, SWIGTYPE_p_PrefixTransformer.getCPtr(transformer));
  }

  
/**
   * @return any custom transformer set for prefix operations, will be null by default.
   */ public
 SWIGTYPE_p_PrefixTransformer getTransformer() {
    long cPtr = libsbmlJNI.CompModelPlugin_getTransformer(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_PrefixTransformer(cPtr, false);
  }

  
/**
   * @return an indicator, whether a custom transformer has been set.
   */ public
 boolean isSetTransformer() {
    return libsbmlJNI.CompModelPlugin_isSetTransformer(swigCPtr, this);
  }

  
/**
   * Unsets any custom prefix transformers. 
   */ public
 void unsetTransformer() {
    libsbmlJNI.CompModelPlugin_unsetTransformer(swigCPtr, this);
  }

}
