/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sbml.libsbml;

/** 
 * <span class="pkg-marker pkg-color-fbc"><a href="group__fbc.html">fbc</a></span>
 Annotation helper class for &ldquo;fbc&rdquo; Version&nbsp;1.
 <p>
 * <p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>

 <p>
 * The {@link Association} class is a helper class for creating annotations to store
 * gene association information in Version&nbsp;1 of the SBML Level&nbsp;3
 * <a href='../../../extensions-summary.html#fbc'>Flux Balance Constraints</a> (&ldquo;fbc&rdquo;) package.  In &ldquo;fbc&rdquo;
 * Version&nbsp;2, the equivalent capability is handled by the {@link FbcAssociation}
 * class and this class (Association) is not used.
 <p>
 * @see FbcAssociation
 * @see ListOfFbcAssociations
 */

public class Association extends SBase {
   private long swigCPtr;

   protected Association(long cPtr, boolean cMemoryOwn)
   {
     super(libsbmlJNI.Association_SWIGUpcast(cPtr), cMemoryOwn);
     swigCPtr = cPtr;
   }

   protected static long getCPtr(Association obj)
   {
     return (obj == null) ? 0 : obj.swigCPtr;
   }

   protected static long getCPtrAndDisown (Association obj)
   {
     long ptr = 0;

     if (obj != null)
     {
       ptr             = obj.swigCPtr;
       obj.swigCMemOwn = false;
     }

     return ptr;
   }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libsbmlJNI.delete_Association(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  
/**
   * Creates a new {@link Association} objet with the given SBML Level, Version, and
   * &ldquo;fbc&rdquo; package version.
   <p>
   * @param level the SBML Level.
   * @param version the Version within the SBML Level.
   * @param pkgVersion the version of the package.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association(long level, long version, long pkgVersion) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_0(level, version, pkgVersion), true);
  }

  
/**
   * Creates a new {@link Association} objet with the given SBML Level, Version, and
   * &ldquo;fbc&rdquo; package version.
   <p>
   * @param level the SBML Level.
   * @param version the Version within the SBML Level.
   * @param pkgVersion the version of the package.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association(long level, long version) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_1(level, version), true);
  }

  
/**
   * Creates a new {@link Association} objet with the given SBML Level, Version, and
   * &ldquo;fbc&rdquo; package version.
   <p>
   * @param level the SBML Level.
   * @param version the Version within the SBML Level.
   * @param pkgVersion the version of the package.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association(long level) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_2(level), true);
  }

  
/**
   * Creates a new {@link Association} objet with the given SBML Level, Version, and
   * &ldquo;fbc&rdquo; package version.
   <p>
   * @param level the SBML Level.
   * @param version the Version within the SBML Level.
   * @param pkgVersion the version of the package.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association() throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_3(), true);
  }

  
/**
   * Creates a new {@link Association} with the given {@link FbcPkgNamespaces} object,
   * and constructed to mimic the XMLNode: a '&lt;gene&gt;' node 
   * argument will result in a  
   * {@link libsbmlConstants#GENE_ASSOCIATION GENE_ASSOCIATION} node; an
   * &lt;and&gt; node argument will result in a
   * {@link libsbmlConstants#AND_ASSOCIATION AND_ASSOCIATION} node; an
   * &lt;or&gt; node argument will result in a
   * {@link libsbmlConstants#OR_ASSOCIATION OR_ASSOCIATION} node.  Any
   * other node will result in a
   * {@link libsbmlConstants#UNKNOWN_ASSOCIATION UNKNOWN_ASSOCIATION} node.
   * 'And' and 'or' nodes will have {@link Association} children that again 
   * parallel the children of the given {@link XMLNode}.
   <p>
   * <p>
 * The package namespaces object used in this constructor is derived from a
 * {@link SBMLNamespaces} object, which encapsulates SBML Level/Version/namespaces
 * information.  It is used to communicate the SBML Level, Version, and 
 * package version and name information used in addition to SBML Level&nbsp;3 Core.  A
 * common approach to using libSBML's {@link SBMLNamespaces} facilities is to create an
 * package namespace object somewhere in a program once, then hand that object
 * as needed to object constructors of that package that accept it as and
 * argument, such as this one.
   <p>
   * @param fbcns the {@link FbcPkgNamespaces} object.
   * @param node the {@link XMLNode} to copy.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association(XMLNode node, FbcPkgNamespaces fbcns) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_4(XMLNode.getCPtr(node), node, FbcPkgNamespaces.getCPtr(fbcns), fbcns), true);
  }

  
/**
   * Creates a new {@link Association} with the given {@link FbcPkgNamespaces} object.
   <p>
   * <p>
 * The package namespaces object used in this constructor is derived from a
 * {@link SBMLNamespaces} object, which encapsulates SBML Level/Version/namespaces
 * information.  It is used to communicate the SBML Level, Version, and 
 * package version and name information used in addition to SBML Level&nbsp;3 Core.  A
 * common approach to using libSBML's {@link SBMLNamespaces} facilities is to create an
 * package namespace object somewhere in a program once, then hand that object
 * as needed to object constructors of that package that accept it as and
 * argument, such as this one.
   <p>
   * @param fbcns the {@link FbcPkgNamespaces} object.
   <p>
   * <p>
 * @note Attempting to add an object to an {@link SBMLDocument} having a different
 * combination of SBML Level, Version and XML namespaces than the object
 * itself will result in an error at the time a caller attempts to make the
 * addition.  A parent object must have compatible Level, Version and XML
 * namespaces.  (Strictly speaking, a parent may also have more XML
 * namespaces than a child, but the reverse is not permitted.)  The
 * restriction is necessary to ensure that an SBML model has a consistent
 * overall structure.  This requires callers to manage their objects
 * carefully, but the benefit is increased flexibility in how models can be
 * created by permitting callers to create objects bottom-up if desired.  In
 * situations where objects are not yet attached to parents (e.g.,
 * {@link SBMLDocument}), knowledge of the intented SBML Level and Version help
 * libSBML determine such things as whether it is valid to assign a
 * particular value to an attribute.  For packages, this means that the 
 * parent object to which this package element is being added must have
 * been created with the package namespace, or that the package namespace
 * was added to it, even if that parent is not a package object itself.
   */ public
 Association(FbcPkgNamespaces fbcns) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_5(FbcPkgNamespaces.getCPtr(fbcns), fbcns), true);
  }

  
/**
   * Copy constructor.
   <p>
   * @param source the instance to copy.
   */ public
 Association(Association source) throws org.sbml.libsbml.SBMLConstructorException {
    this(libsbmlJNI.new_Association__SWIG_6(Association.getCPtr(source), source), true);
  }

  
/**
   * Predicate returning <code>true</code> if this abstract {@link Association} is of type
   * {@link FbcAnd}
   <p>
   * @return <code>true</code> if this abstract {@link Association} is of type {@link FbcAnd}, <code>false</code>
   * otherwise
   */ public
 boolean isFbcAnd() {
    return libsbmlJNI.Association_isFbcAnd(swigCPtr, this);
  }

  
/**
   * Predicate returning <code>true</code> if this abstract {@link Association} is of type
   * {@link FbcOr}
   <p>
   * @return <code>true</code> if this abstract {@link Association} is of type {@link FbcOr}, <code>false</code>
   * otherwise
   */ public
 boolean isFbcOr() {
    return libsbmlJNI.Association_isFbcOr(swigCPtr, this);
  }

  
/**
   * Predicate returning <code>true</code> if this abstract {@link Association} is of type
   * {@link GeneProductRef}
   <p>
   * @return <code>true</code> if this abstract {@link Association} is of type {@link GeneProductRef},
   * <code>false</code> otherwise
   */ public
 boolean isGeneProductRef() {
    return libsbmlJNI.Association_isGeneProductRef(swigCPtr, this);
  }

  
/**
   * Returns the string of the 'type' attribute of this {@link Association} object.
   <p>
   * @return the string of the 'type' attribute of this {@link Association} object.
   */ public
 int getType() {
    return libsbmlJNI.Association_getType(swigCPtr, this);
  }

  
/**
   * Predicate returning <code>true</code> if this {@link Association}'s 'type' attribute is
   * set.
   <p>
   * @return <code>true</code> if this {@link Association} object's 'type' attribute has been set,
   * otherwise <code>false</code> is returned.
   */ public
 boolean isSetType() {
    return libsbmlJNI.Association_isSetType(swigCPtr, this);
  }

  
/**
   * Sets the SIdRef string of the 'type' attribute of this {@link Association} object.
   <p>
   * @param type a SIdRef string to be set.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE}
   * </ul>
   */ public
 int setType(int type) {
    return libsbmlJNI.Association_setType(swigCPtr, this, type);
  }

  
/**
   * Unsets the value of the 'id' attribute of this {@link Association} object.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int unsetType() {
    return libsbmlJNI.Association_unsetType(swigCPtr, this);
  }

  
/**
   * Returns the string of the 'reference' attribute of this {@link Association} object.
   <p>
   * @return the string of the 'reference' attribute of this {@link Association} object.
   */ public
 String getReference() {
    return libsbmlJNI.Association_getReference(swigCPtr, this);
  }

  
/**
   * Predicate returning <code>true</code> if this {@link Association}'s 'reference' attribute
   * has been set.
   <p>
   * @return <code>true</code> if this {@link Association} object's 'reference' attribute has been set,
   * otherwise <code>false</code> is returned.
   */ public
 boolean isSetReference() {
    return libsbmlJNI.Association_isSetReference(swigCPtr, this);
  }

  
/**
   * Sets the SIdRef string of the 'reference' attribute of this {@link Association} object.
   <p>
   * @param reference a SIdRef string to be set.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE}
   * </ul>
   */ public
 int setReference(String reference) {
    return libsbmlJNI.Association_setReference(swigCPtr, this, reference);
  }

  
/**
   * Unsets the value of the 'id' attribute of this {@link Association} object.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int unsetReference() {
    return libsbmlJNI.Association_unsetReference(swigCPtr, this);
  }

  
/**
   * Adds a gene with the given <code>id</code> to the association.
   <p>
   * @param id the gene name.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int addGene(String id) {
    return libsbmlJNI.Association_addGene(swigCPtr, this, id);
  }

  
/**
   * Returns the number of child Associations of this {@link Association} object.
   <p>
   * @return the number of associations.
   */ public
 long getNumAssociations() {
    return libsbmlJNI.Association_getNumAssociations(swigCPtr, this);
  }

  
/**
   * Adds a child {@link Association} to this {@link Association} object.
   <p>
   * @param association the {@link Association} object to add.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int addAssociation(Association association) {
    return libsbmlJNI.Association_addAssociation(swigCPtr, this, Association.getCPtr(association), association);
  }

  
/**
   * Removes the child Associations with the given <code>index</code> from this
   * {@link Association} object.
   <p>
   * @param index the index number of the item to remove.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int removeAssociation(int index) {
    return libsbmlJNI.Association_removeAssociation(swigCPtr, this, index);
  }

  
/**
   * Removes all children of this {@link Association} object.
   <p>
   * <p>
 * @return integer value indicating success/failure of the
 * function.   The possible values
 * returned by this function are:
   * <ul>
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS}
   * <li> {@link libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED}
   * </ul>
   */ public
 int clearAssociations() {
    return libsbmlJNI.Association_clearAssociations(swigCPtr, this);
  }

  
/**
   * Creates a new {@link Association} of type 'and'.
   <p>
   * This method does not actually add the created {@link Association} as a child of
   * this {@link Association} object or do anything else with it&mdash;the returning
   * pointer is now owned by the caller.
   <p>
   * @return a new 'and' type association.
   */ public
 Association createAnd() {
    long cPtr = libsbmlJNI.Association_createAnd(swigCPtr, this);
    return (cPtr == 0) ? null : new Association(cPtr, false);
  }

  
/**
   * Creates a new {@link Association} of type 'or'.
   <p>
   * This method does not actually add the created {@link Association} as a child of
   * this {@link Association} object or do anything else with it&mdash;the returning
   * pointer is now owned by the caller.
   <p>
   * @return a new 'or' type association.
   */ public
 Association createOr() {
    long cPtr = libsbmlJNI.Association_createOr(swigCPtr, this);
    return (cPtr == 0) ? null : new Association(cPtr, false);
  }

  
/**
   * Creates a new {@link Association} of type 'and' with a given gene reference.
   <p>
   * This method does not actually add the created {@link Association} as a child of
   * this {@link Association} object or do anything else with it&mdash;the returning
   * pointer is now owned by the caller.
   <p>
   * @param reference the gene reference, as a string.
   <p>
   * @return a new {@link Association} object.
   */ public
 Association createGene(String reference) {
    long cPtr = libsbmlJNI.Association_createGene__SWIG_0(swigCPtr, this, reference);
    return (cPtr == 0) ? null : new Association(cPtr, false);
  }

  
/**
   * Creates a new {@link Association} of type 'and' with a given gene reference.
   <p>
   * This method does not actually add the created {@link Association} as a child of
   * this {@link Association} object or do anything else with it&mdash;the returning
   * pointer is now owned by the caller.
   <p>
   * @param reference the gene reference, as a string.
   <p>
   * @return a new {@link Association} object.
   */ public
 Association createGene() {
    long cPtr = libsbmlJNI.Association_createGene__SWIG_1(swigCPtr, this);
    return (cPtr == 0) ? null : new Association(cPtr, false);
  }

  
/**
   * Creates an {@link XMLNode} object from this {@link Association} object.
   */ public
 XMLNode toXML() {
    return new XMLNode(libsbmlJNI.Association_toXML(swigCPtr, this), true);
  }

  
/**
   * Returns the XML element name of this SBML object.
   <p>
   * @return the name of this element, as a text string.
   */ public
 String getElementName() {
    return libsbmlJNI.Association_getElementName(swigCPtr, this);
  }

  
/**
   * Creates and returns a deep copy of this {@link Association} object.
   <p>
   * @return a (deep) copy of this {@link Association} object.
   */ public
 Association cloneObject() {
    long cPtr = libsbmlJNI.Association_cloneObject(swigCPtr, this);
    return (cPtr == 0) ? null : new Association(cPtr, true);
  }

  
/**
   * Returns the libSBML type code of this object instance.
   <p>
   * <p>
 * LibSBML attaches an identifying code to every kind of SBML object.  These
 * are integer constants known as <em>SBML type codes</em>.  The names of all
 * the codes begin with the characters <code>SBML_</code>.
 * In the Java language interface for libSBML, the
 * type codes are defined as static integer constants in the interface class
 * {@link libsbmlConstants}.    Note that different Level&nbsp;3
 * package plug-ins may use overlapping type codes; to identify the package
 * to which a given object belongs, call the 
 * <code>{@link SBase#getPackageName()}
 * </code>
 * method on the object.
 <p>
 * The exception to this is lists:  all SBML-style list elements have the type 
 * {@link libsbmlConstants#SBML_LIST_OF SBML_LIST_OF}, regardless of what package they 
 * are from.
   <p>
   * @return the SBML type code for this object:
   * {@link libsbmlConstants#SBML_FBC_ASSOCIATION SBML_FBC_ASSOCIATION}.
   <p>
   * <p>
 * @warning <span class='warning'>The specific integer values of the possible
 * type codes may be reused by different libSBML plug-ins for SBML Level&nbsp;3.
 * packages,  To fully identify the correct code, <strong>it is necessary to
 * invoke both getPackageName() and getTypeCode()</strong> (or 
 * {@link ListOf#getItemTypeCode()}).</span>
   <p>
   * @see #getElementName()
   * @see #getPackageName()
   */ public
 int getTypeCode() {
    return libsbmlJNI.Association_getTypeCode(swigCPtr, this);
  }

  
/**
   * Parses a gene association in infix format and returns a corresponding
   * {@link Association} object.
   <p>
   * This parses a string that has a list of gene names and conjunctions
   * or disjunctions.  For example:
   * <pre class='fragment'>
(b2422) and (b2425) and (b2423) and (b2424) or (b2422) and (b2423) and (b2424) and (b2413) and (b3917)
</pre>
   <p>
   * @param association the string to parse.
   <p>
   * @return the parsed association, or <code>null</code> in case of an error.
   <p>
   * 
   <p>
   * @see #toInfix()
   */ public
 static Association parseInfixAssociation(String association) {
    long cPtr = libsbmlJNI.Association_parseInfixAssociation(association);
    return (cPtr == 0) ? null : new Association(cPtr, false);
  }

  
/**
   * Converts this {@link Association} object into an infix string representation.
   * The format is the same as is found in parseInfixAssociation().
   <p>
   * @return the association as infix string.
   <p>
   * @see #parseInfixAssociation(String association)
   */ public
 String toInfix() {
    return libsbmlJNI.Association_toInfix(swigCPtr, this);
  }

}
